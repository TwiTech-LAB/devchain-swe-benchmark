{
  "instance_id": "django__django-14007",
  "status": "completed",
  "patch": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 55b1691166..dff1f2fbc2 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -872,6 +872,13 @@ class Model(metaclass=ModelBase):\n             results = self._do_insert(cls._base_manager, using, fields, returning_fields, raw)\n             if results:\n                 for value, field in zip(results[0], returning_fields):\n+                    expression = field.cached_col\n+                    converters = (\n+                        connections[using].ops.get_db_converters(expression) +\n+                        expression.get_db_converters(connections[using])\n+                    )\n+                    for converter in converters:\n+                        value = converter(value, expression, connections[using])\n                     setattr(self, field.attname, value)\n         return updated\n \ndiff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 387deca527..349f4c68d0 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -502,9 +502,20 @@ class QuerySet:\n                 returned_columns = self._batched_insert(\n                     objs_with_pk, fields, batch_size, ignore_conflicts=ignore_conflicts,\n                 )\n+                # Precompute converters per field (indexed by position in db_returning_fields)\n+                converters_map = {\n+                    i: (\n+                        field.cached_col,\n+                        connection.ops.get_db_converters(field.cached_col) + field.cached_col.get_db_converters(connection),\n+                    )\n+                    for i, field in enumerate(opts.db_returning_fields)\n+                }\n                 for obj_with_pk, results in zip(objs_with_pk, returned_columns):\n-                    for result, field in zip(results, opts.db_returning_fields):\n+                    for i, (result, field) in enumerate(zip(results, opts.db_returning_fields)):\n                         if field != opts.pk:\n+                            expression, converters = converters_map[i]\n+                            for converter in converters:\n+                                result = converter(result, expression, connection)\n                             setattr(obj_with_pk, field.attname, result)\n                 for obj_with_pk in objs_with_pk:\n                     obj_with_pk._state.adding = False\n@@ -516,8 +527,19 @@ class QuerySet:\n                 )\n                 if connection.features.can_return_rows_from_bulk_insert and not ignore_conflicts:\n                     assert len(returned_columns) == len(objs_without_pk)\n+                # Precompute converters per field (indexed by position in db_returning_fields)\n+                converters_map = {\n+                    i: (\n+                        field.cached_col,\n+                        connection.ops.get_db_converters(field.cached_col) + field.cached_col.get_db_converters(connection),\n+                    )\n+                    for i, field in enumerate(opts.db_returning_fields)\n+                }\n                 for obj_without_pk, results in zip(objs_without_pk, returned_columns):\n-                    for result, field in zip(results, opts.db_returning_fields):\n+                    for i, (result, field) in enumerate(zip(results, opts.db_returning_fields)):\n+                        expression, converters = converters_map[i]\n+                        for converter in converters:\n+                            result = converter(result, expression, connection)\n                         setattr(obj_without_pk, field.attname, result)\n                     obj_without_pk._state.adding = False\n                     obj_without_pk._state.db = self.db\n",
  "epics_created": 1,
  "epics_completed": 1,
  "start_time": "2026-01-16T12:24:50.226178",
  "end_time": "2026-01-16T12:39:53.707234",
  "duration_seconds": 903.481056,
  "error_message": null,
  "workspace_path": "./workspaces/django__django-14007",
  "epic_comments": [
    {
      "epic_id": "8bd7b8c9-1e7f-4b62-94ce-21ca88d28308",
      "epic_title": "Fix: django__django-14007",
      "comment_id": "e3cea4bb-aa1e-404e-8272-e6f4eb00d410",
      "author_name": "Brainstormer",
      "content": "## Fix Summary\nFixed the bug where `from_db_value` and other database converters were not being called for `returning_fields` on INSERT operations. The issue affected both `Model.save()` (via `_save_table`) and `QuerySet.bulk_create()`.\n\nThe root cause was that when INSERT returns values (via RETURNING clause on supported backends), the returned values were being set directly on model instances without passing through the field's database converters.\n\n## Files Modified\n- **django/db/models/base.py**: Added converter application in `_save_table()` method (lines 875-877). After INSERT, the returned values now pass through `field.get_db_converters(connection)` before being set on the model instance.\n- **django/db/models/query.py**: Added converter application in `bulk_create()` method in two places (lines 508-510 for objects with pk, lines 524-526 for objects without pk).\n\n## Test Results\n- **Baseline test file:** tests/bulk_create/tests.py\n- **Baseline (before fix):** 30 passed, 0 failed, 0 errors (6 skipped)\n- **After fix:** 30 passed, 0 failed, 0 errors (6 skipped)\n- **Regression check:** No new failures introduced\n\nAdditional test results:\n- model_fields: 422 passed (10 skipped)\n- basic: 59 passed (2 skipped)\n- queries + get_or_create: 454 passed (15 skipped, 2 expected failures)\n\n## Additional Verification\nCreated a custom test script that demonstrates the fix:\n- Custom `MyAutoField` with `from_db_value` that wraps values in `MyIntWrapper`\n- Verified `create()` now returns `MyIntWrapper` (was returning raw `int` before)\n- Note: `bulk_create()` test on SQLite returns `None` because SQLite doesn't support `can_return_rows_from_bulk_insert`, but the fix is in place for PostgreSQL and other backends that support this feature\n\n## Concerns\n- The fix only applies field-level converters via `field.get_db_converters(connection)`, not backend-level converters from `connection.ops.get_db_converters()`. This is because the backend method expects an expression object with `output_field` attribute, which fields don't have. However, this is sufficient for the reported issue since `from_db_value` is returned by `field.get_db_converters()`.\n- Backend converters are typically for date/time/decimal type conversions which are handled differently in the INSERT path.",
      "created_at": "2026-01-16T11:30:36.317Z"
    },
    {
      "epic_id": "8bd7b8c9-1e7f-4b62-94ce-21ca88d28308",
      "epic_title": "Fix: django__django-14007",
      "comment_id": "888007a1-54bf-4968-9365-4bcbc63d1793",
      "author_name": "Code Reviewer",
      "content": "Code Review FAILED\n\nIssues Found:\n- INSERT-returned values are passed through `field.get_db_converters()`, but each converter is called with `field` passed as the `expression` argument (`converter(value, field, connection)`). In normal result conversion paths, Django passes an `Expression` (e.g., `Col`) which has `output_field`; custom `from_db_value()` implementations may rely on `expression.output_field` and would break here.\n- Backend-level converters (`connection.ops.get_db_converters(expression)`) aren\u2019t applied, so INSERT RETURNING conversion behavior can still differ from SELECT for some backends/types.\n\nRequired Changes:\n- For each returned field, construct an `Expression` (e.g., `field.get_col(field.model._meta.db_table)` / `field.cached_col`) and apply converters using the same contract as `SQLCompiler.apply_converters`: `backend_converters + expression.get_db_converters(connection)`, invoked as `converter(value, expression, connection)`.\n- Prefer caching the converter list per field rather than recomputing inside the inner loop.\n",
      "created_at": "2026-01-16T11:33:28.902Z"
    },
    {
      "epic_id": "8bd7b8c9-1e7f-4b62-94ce-21ca88d28308",
      "epic_title": "Fix: django__django-14007",
      "comment_id": "b2478878-045f-4dc5-b374-abb68cd8fbb4",
      "author_name": "Brainstormer",
      "content": "## Fix Updated (Addressing Review Feedback)\n\nAddressed all concerns from code review:\n\n### Changes Made\n\n1. **Use proper Expression with `output_field`**: Now using `field.cached_col` which returns a `Col` expression that properly has `output_field` attribute. This ensures `from_db_value()` implementations that rely on `expression.output_field` will work correctly.\n\n2. **Apply backend converters**: Now calling both `field.get_db_converters(connection)` AND `connection.ops.get_db_converters(field.cached_col)` to match the same behavior as `SQLCompiler.apply_converters`.\n\n3. **Cache converter list per field**: Converters are now precomputed into a `converters_map` dictionary before iterating over objects, avoiding redundant computation in the inner loop.\n\n### Files Modified\n- **django/db/models/base.py**: `_save_table()` now uses `field.cached_col` and applies both field and backend converters with proper expression argument\n- **django/db/models/query.py**: `bulk_create()` precomputes converters map for both `objs_with_pk` and `objs_without_pk` sections\n\n### Test Results\n- bulk_create: 30 passed (6 skipped)\n- model_fields + basic + queries + get_or_create: 935 passed (27 skipped, 2 expected failures)\n- Custom verification script: `create()` now correctly returns `MyIntWrapper` type\n\n### Implementation Details\nThe fix now mirrors the contract used in `SQLCompiler.apply_converters`:\n```python\nexpression = field.cached_col\nconverters = field.get_db_converters(connection) + connection.ops.get_db_converters(expression)\nfor converter in converters:\n    value = converter(value, expression, connection)\n```",
      "created_at": "2026-01-16T11:35:46.492Z"
    },
    {
      "epic_id": "8bd7b8c9-1e7f-4b62-94ce-21ca88d28308",
      "epic_title": "Fix: django__django-14007",
      "comment_id": "71d8ca1c-77af-4c13-80dd-b96c1f7405f0",
      "author_name": "Code Reviewer",
      "content": "Code Review FAILED (follow-up)\n\nIssues Found:\n- Converter order is reversed vs Django\u2019s normal result conversion pipeline. Current code applies `field.get_db_converters()` before `connection.ops.get_db_converters(expression)`, but `SQLCompiler.get_converters()` applies backend converters first, then expression/field converters. This can break when backend converters expect raw DB values and `from_db_value()` returns a wrapper.\n- The fix still doesn\u2019t mirror the standard contract of using `expression.get_db_converters(connection)` (which includes `output_field.get_db_converters()` and any expression-level conversion). Using `field.get_db_converters()` directly risks divergence from SELECT behavior.\n\nRequired Changes:\n- Build converters exactly like `SQLCompiler.get_converters()`:\n  - `expression = field.cached_col`\n  - `converters = connection.ops.get_db_converters(expression) + expression.get_db_converters(connection)`\n  - Apply as `value = converter(value, expression, connection)`.\n- Update both `_save_table()` and `bulk_create()` accordingly (and cache per-field converter lists as you already started doing).\n",
      "created_at": "2026-01-16T11:36:58.867Z"
    },
    {
      "epic_id": "8bd7b8c9-1e7f-4b62-94ce-21ca88d28308",
      "epic_title": "Fix: django__django-14007",
      "comment_id": "d6282694-3342-48c9-a0d2-56c61847a2a1",
      "author_name": "Brainstormer",
      "content": "## Fix Updated (Addressing Second Review Feedback)\n\nFixed the converter order and expression usage to exactly match `SQLCompiler.get_converters()`:\n\n### Changes Made\n\n1. **Fixed converter order**: Now uses `backend_converters + field_converters` (backend first, then expression):\n   ```python\n   converters = (\n       connection.ops.get_db_converters(expression) +\n       expression.get_db_converters(connection)\n   )\n   ```\n\n2. **Use `expression.get_db_converters()`**: Now calling `expression.get_db_converters(connection)` instead of `field.get_db_converters(connection)` to match the exact contract used in `SQLCompiler.get_converters()`.\n\n### Implementation now exactly matches SQLCompiler.get_converters():\n```python\n# SQLCompiler.get_converters() pattern:\nbackend_converters = self.connection.ops.get_db_converters(expression)\nfield_converters = expression.get_db_converters(self.connection)\nconverters[i] = (backend_converters + field_converters, expression)\n\n# Our implementation:\nexpression = field.cached_col\nconverters = (\n    connection.ops.get_db_converters(expression) +\n    expression.get_db_converters(connection)\n)\n```\n\n### Test Results\n- bulk_create + model_fields + basic: 511 passed (18 skipped)\n- Custom verification script: `create()` correctly returns `MyIntWrapper` type\n\n### Files Modified\n- **django/db/models/base.py**: `_save_table()` lines 875-882\n- **django/db/models/query.py**: `bulk_create()` lines 506-511 and 530-535",
      "created_at": "2026-01-16T11:38:38.331Z"
    },
    {
      "epic_id": "8bd7b8c9-1e7f-4b62-94ce-21ca88d28308",
      "epic_title": "Fix: django__django-14007",
      "comment_id": "f83155b6-0b72-4d95-8dab-85a3600300dc",
      "author_name": "Code Reviewer",
      "content": "Code review PASSED.\n\n- Changes now match Django\u2019s normal conversion contract: uses `expression = field.cached_col`, applies `connection.ops.get_db_converters(expression) + expression.get_db_converters(connection)`, and calls converters with `(value, expression, connection)`.\n- No test/build files modified; changes are focused to `django/db/models/base.py` and `django/db/models/query.py`.\n",
      "created_at": "2026-01-16T11:39:43.092Z"
    }
  ]
}