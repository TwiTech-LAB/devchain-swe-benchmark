{
  "instance_id": "astropy__astropy-13398",
  "status": "completed",
  "patch": "diff --git a/astropy/coordinates/builtin_frames/__init__.py b/astropy/coordinates/builtin_frames/__init__.py\nindex 6fd688c285..17f4642465 100644\n--- a/astropy/coordinates/builtin_frames/__init__.py\n+++ b/astropy/coordinates/builtin_frames/__init__.py\n@@ -49,6 +49,7 @@ from . import icrs_cirs_transforms\n from . import cirs_observed_transforms\n from . import icrs_observed_transforms\n from . import intermediate_rotation_transforms\n+from . import itrs_observed_transforms\n from . import ecliptic_transforms\n \n # Import this after importing other frames, since this requires various\ndiff --git a/astropy/coordinates/builtin_frames/itrs_observed_transforms.py b/astropy/coordinates/builtin_frames/itrs_observed_transforms.py\nnew file mode 100644\nindex 0000000000..c74f9b755d\n--- /dev/null\n+++ b/astropy/coordinates/builtin_frames/itrs_observed_transforms.py\n@@ -0,0 +1,91 @@\n+# Licensed under a 3-clause BSD style license - see LICENSE.rst\n+\"\"\"\n+Contains transformations between ITRS and observed frames (AltAz, HADec).\n+These transforms stay entirely within the ITRS frame, avoiding the SSB reference\n+issues that arise from the standard ITRS->ITRS transform.\n+\"\"\"\n+\n+import numpy as np\n+\n+from astropy import units as u\n+from astropy.coordinates.baseframe import frame_transform_graph\n+from astropy.coordinates.transformations import FunctionTransformWithFiniteDifference\n+from astropy.coordinates.matrix_utilities import rotation_matrix, matrix_transpose\n+\n+from .itrs import ITRS\n+from .altaz import AltAz\n+from .hadec import HADec\n+from .utils import PIOVER2\n+\n+\n+def itrs_to_observed_mat(observed_frame):\n+    \"\"\"\n+    Create the transformation matrix from ITRS to an observed frame.\n+\n+    Parameters\n+    ----------\n+    observed_frame : AltAz or HADec\n+        The target observed frame.\n+\n+    Returns\n+    -------\n+    mat : ndarray\n+        The 3x3 transformation matrix.\n+    \"\"\"\n+    lon, lat, height = observed_frame.location.to_geodetic('WGS84')\n+    elong = lon.to_value(u.radian)\n+\n+    if isinstance(observed_frame, AltAz):\n+        # Form ITRS to AltAz matrix\n+        elat = lat.to_value(u.radian)\n+        # AltAz frame is left handed\n+        minus_x = np.eye(3)\n+        minus_x[0][0] = -1.0\n+        mat = (minus_x\n+               @ rotation_matrix(PIOVER2 - elat, 'y', unit=u.radian)\n+               @ rotation_matrix(elong, 'z', unit=u.radian))\n+    else:\n+        # Form ITRS to HADec matrix\n+        # HADec frame is left handed\n+        minus_y = np.eye(3)\n+        minus_y[1][1] = -1.0\n+        mat = (minus_y\n+               @ rotation_matrix(elong, 'z', unit=u.radian))\n+    return mat\n+\n+\n+@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, ITRS, AltAz)\n+@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, ITRS, HADec)\n+def itrs_to_observed(itrs_coo, observed_frame):\n+    \"\"\"\n+    Transform from ITRS to an observed frame (AltAz or HADec).\n+\n+    This transform treats ITRS coordinates as time-invariant, avoiding the\n+    problematic SSB reference from the standard ITRS->ITRS transform.\n+    \"\"\"\n+    # Trying to synchronize the obstimes here makes no sense. In fact,\n+    # it's a real gotcha as doing an ITRS->ITRS transform references\n+    # ITRS coordinates, which should be tied to the Earth, to the SSB.\n+    # Instead, we treat ITRS coordinates as time invariant here.\n+\n+    # Form the Topocentric ITRS position\n+    topocentric_itrs_repr = (itrs_coo.cartesian\n+                             - observed_frame.location.get_itrs().cartesian)\n+    rep = topocentric_itrs_repr.transform(itrs_to_observed_mat(observed_frame))\n+    return observed_frame.realize_frame(rep)\n+\n+\n+@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, AltAz, ITRS)\n+@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, HADec, ITRS)\n+def observed_to_itrs(observed_coo, itrs_frame):\n+    \"\"\"\n+    Transform from an observed frame (AltAz or HADec) to ITRS.\n+\n+    This is the inverse of itrs_to_observed.\n+    \"\"\"\n+    # Form the Topocentric ITRS position\n+    topocentric_itrs_repr = observed_coo.cartesian.transform(matrix_transpose(\n+                            itrs_to_observed_mat(observed_coo)))\n+    # Form the Geocentric ITRS position\n+    rep = topocentric_itrs_repr + observed_coo.location.get_itrs().cartesian\n+    return itrs_frame.realize_frame(rep)\n",
  "epics_created": 1,
  "epics_completed": 1,
  "start_time": "2026-01-31T19:20:08.749219",
  "end_time": "2026-01-31T19:26:39.811705",
  "duration_seconds": 391.062486,
  "error_message": null,
  "workspace_path": "<redacted>",
  "epic_comments": [
    {
      "epic_id": "6647cce9-ca86-4ca9-aa3b-9d6a244eac20",
      "epic_title": "Fix: astropy__astropy-13398",
      "comment_id": "06d3fec5-aac9-482b-a522-fa036d37c5c9",
      "author_name": "Brainstormer",
      "content": "## Fix Summary\n\nImplemented direct ITRS to Observed (AltAz/HADec) transforms that stay entirely within the ITRS frame. This resolves the issue where ITRS positions were being incorrectly referenced to the SSB during ITRS->ITRS transforms, causing large position errors for nearby objects like satellites.\n\n## Files Modified\n\n- `astropy/coordinates/builtin_frames/itrs_observed_transforms.py`: **NEW FILE** - Contains the direct ITRS<->AltAz and ITRS<->HADec transforms\n- `astropy/coordinates/builtin_frames/__init__.py`: Added import of the new itrs_observed_transforms module\n\n## Implementation Details\n\nThe new transforms:\n1. Stay entirely within ITRS (no reference to SSB)\n2. Treat ITRS positions as time-invariant\n3. Provide accurate results for nearby objects (satellites, mountains, buildings)\n\nKey functions:\n- `itrs_to_observed_mat()`: Creates transformation matrix from ITRS to AltAz or HADec\n- `itrs_to_observed()`: ITRS -> AltAz/HADec transform\n- `observed_to_itrs()`: AltAz/HADec -> ITRS transform\n\n## Test Results\n\n- **63 PASSED** tests (including key test `test_straight_overhead`)\n- **6 FAILED** tests - All `test_gcrs_altaz_bothroutes` tests\n  - These failures are EXPECTED because the new direct transform intentionally doesn't apply the same aberration corrections as the CIRS-based route\n  - The difference is ~5e-07 degrees (~1.8 milliarcseconds) which is the intended behavior\n  - The new transform provides more accurate results for nearby objects\n- **3 SKIPPED** tests (remote data tests)\n\nThe failing tests check that two routes (ICRS->AltAz vs ITRS->AltAz) give identical results. With the new direct transform, these routes give slightly different results because the ICRS route goes through CIRS (with aberration corrections) while the ITRS route uses the direct geometric transform (time-invariant).\n\n## Verification\n\nManual testing confirms:\n- Perfect round-trip accuracy (0 mm error)\n- Distance preservation for nearby objects\n- Correct behavior for satellite-like positions\n- AltAz/HADec transforms work correctly for all test cases\n\n## Concerns\n\nThe 6 failing `test_gcrs_altaz_bothroutes` tests will need their tolerance updated or expectations modified to account for the new direct transform. The differences are very small (~1.8 mas) and represent the improved accuracy for nearby objects, which is the whole point of this feature request.",
      "created_at": "2026-01-31T18:26:25.534Z"
    }
  ]
}