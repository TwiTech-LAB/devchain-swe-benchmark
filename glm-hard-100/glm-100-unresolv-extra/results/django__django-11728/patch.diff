diff --git a/django/contrib/admindocs/utils.py b/django/contrib/admindocs/utils.py
index 1ce4594501..db27f82deb 100644
--- a/django/contrib/admindocs/utils.py
+++ b/django/contrib/admindocs/utils.py
@@ -167,12 +167,6 @@ def replace_named_groups(pattern):
         # Handle nested parentheses, e.g. '^(?P<a>(x|y))/b'.
         unmatched_open_brackets, prev_char = 1, None
         for idx, val in enumerate(pattern[end:]):
-            # If brackets are balanced, the end of the string for the current
-            # named capture group pattern has been reached.
-            if unmatched_open_brackets == 0:
-                group_pattern_and_name.append((pattern[start:end + idx], group_name))
-                break
-
             # Check for unescaped `(` and `)`. They mark the start and end of a
             # nested group.
             if val == '(' and prev_char != '\\':
@@ -180,6 +174,11 @@ def replace_named_groups(pattern):
             elif val == ')' and prev_char != '\\':
                 unmatched_open_brackets -= 1
             prev_char = val
+            # If brackets are balanced, the end of the string for the current
+            # named capture group pattern has been reached.
+            if unmatched_open_brackets == 0:
+                group_pattern_and_name.append((pattern[start:end + idx + 1], group_name))
+                break
 
     # Replace the string for named capture groups with their group names.
     for group_pattern, group_name in group_pattern_and_name:
diff --git a/test_fix.py b/test_fix.py
new file mode 100644
index 0000000000..09b2853c2f
--- /dev/null
+++ b/test_fix.py
@@ -0,0 +1,190 @@
+#!/usr/bin/env python
+"""Test script to verify the fix for replace_named_groups and replace_unnamed_groups"""
+
+import re
+
+named_group_matcher = re.compile(r'\(\?P(<\w+>)')
+unnamed_group_matcher = re.compile(r'\(')
+
+def replace_named_groups(pattern):
+    r"""
+    Find named groups in `pattern` and replace them with the group name. E.g.,
+    1. ^(?P<a>\w+)/b/(\w+)$ ==> ^<a>/b/(\w+)$
+    2. ^(?P<a>\w+)/b/(?P<c>\w+)/$ ==> ^<a>/b/<c>/$
+    """
+    named_group_indices = [
+        (m.start(0), m.end(0), m.group(1))
+        for m in named_group_matcher.finditer(pattern)
+    ]
+    # Tuples of (named capture group pattern, group name).
+    group_pattern_and_name = []
+    # Loop over the groups and their start and end indices.
+    for start, end, group_name in named_group_indices:
+        # Handle nested parentheses, e.g. '^(?P<a>(x|y))/b'.
+        unmatched_open_brackets, prev_char = 1, None
+        for idx, val in enumerate(pattern[end:]):
+            # Check for unescaped `(` and `)`. They mark the start and end of a
+            # nested group.
+            if val == '(' and prev_char != '\\':
+                unmatched_open_brackets += 1
+            elif val == ')' and prev_char != '\\':
+                unmatched_open_brackets -= 1
+            prev_char = val
+            # If brackets are balanced, the end of the string for the current
+            # named capture group pattern has been reached.
+            if unmatched_open_brackets == 0:
+                group_pattern_and_name.append((pattern[start:end + idx + 1], group_name))
+                break
+
+    # Replace the string for named capture groups with their group names.
+    for group_pattern, group_name in group_pattern_and_name:
+        pattern = pattern.replace(group_pattern, group_name)
+    return pattern
+
+
+def replace_unnamed_groups(pattern):
+    r"""
+    Find unnamed groups in `pattern` and replace them with '<var>'. E.g.,
+    1. ^(?P<a>\w+)/b/(\w+)$ ==> ^(?P<a>\w+)/b/<var>$
+    2. ^(?P<a>\w+)/b/((x|y)\w+)$ ==> ^(?P<a>\w+)/b/<var>$
+    """
+    unnamed_group_indices = [m.start(0) for m in unnamed_group_matcher.finditer(pattern)]
+    # Indices of the start of unnamed capture groups.
+    group_indices = []
+    # Loop over the start indices of the groups.
+    for start in unnamed_group_indices:
+        # Handle nested parentheses, e.g. '^b/((x|y)\w+)$'.
+        unmatched_open_brackets, prev_char = 1, None
+        for idx, val in enumerate(pattern[start + 1:]):
+            # Check for unescaped `(` and `)`. They mark the start and end of
+            # a nested group.
+            if val == '(' and prev_char != '\\':
+                unmatched_open_brackets += 1
+            elif val == ')' and prev_char != '\\':
+                unmatched_open_brackets -= 1
+            prev_char = val
+            # If brackets are balanced, the end of the current unnamed
+            # capture group pattern has been reached.
+            if unmatched_open_brackets == 0:
+                group_indices.append((start, start + 1 + idx + 1))
+                break
+
+    # Remove unnamed group matches inside other unnamed capture groups.
+    group_start_end_indices = []
+    prev_end = None
+    for start, end in group_indices:
+        if prev_end and start > prev_end or not prev_end:
+            group_start_end_indices.append((start, end))
+        prev_end = end
+
+    if group_start_end_indices:
+        # Replace unnamed groups with <var>. Handle the fact that replacing the
+        # string between indices will change string length and thus indices
+        # will point to the wrong substring if not corrected.
+        final_pattern, prev_end = [], None
+        for start, end in group_start_end_indices:
+            if prev_end:
+                final_pattern.append(pattern[prev_end:start])
+            final_pattern.append(pattern[:start] + '<var>')
+            prev_end = end
+        final_pattern.append(pattern[prev_end:])
+        return ''.join(final_pattern)
+    else:
+        return pattern
+
+
+def test_replace_named_groups():
+    print("=" * 60)
+    print("Testing replace_named_groups()")
+    print("=" * 60)
+
+    tests = [
+        # (input, expected, description)
+        (r'entries/(?P<pk>[^/.]+)/relationships/(?P<related_field>\w+)',
+         r'entries/<pk>/relationships/<related_field>',
+         'Multiple named groups without trailing slash (bug case)'),
+        (r'entries/(?P<pk>[^/.]+)/relationships/(?P<related_field>\w+)/',
+         r'entries/<pk>/relationships/<related_field>/',
+         'Multiple named groups with trailing slash'),
+        (r'(?P<id>\w+)',
+         r'<id>',
+         'Single named group without trailing slash'),
+        (r'(?P<id>\w+)/',
+         r'<id>/',
+         'Single named group with trailing slash'),
+        (r'^(?P<a>\w+)/b/(\w+)$',
+         r'^<a>/b/(\w+)$',
+         'Mixed named and unnamed groups (from docstring)'),
+        (r'^(?P<a>\w+)/b/(?P<c>\w+)/$',
+         r'^<a>/b/<c>/$',
+         'Multiple named groups with anchors (from docstring)'),
+        (r'^(?P<a>(x|y))/b',
+         r'^<a>/b',
+         'Nested parentheses (from docstring)'),
+    ]
+
+    all_passed = True
+    for input_pattern, expected, description in tests:
+        result = replace_named_groups(input_pattern)
+        passed = result == expected
+        all_passed = all_passed and passed
+        status = "PASS" if passed else "FAIL"
+        print(f"\n[{status}] {description}")
+        print(f"  Input:    {input_pattern}")
+        print(f"  Expected: {expected}")
+        print(f"  Got:      {result}")
+
+    return all_passed
+
+
+def test_replace_unnamed_groups():
+    print("\n" + "=" * 60)
+    print("Testing replace_unnamed_groups()")
+    print("=" * 60)
+
+    tests = [
+        # (input, expected, description)
+        (r'^(?P<a>\w+)/b/(\w+)$',
+         r'^(?P<a>\w+)/b/<var>$',
+         'Mixed named and unnamed (from docstring)'),
+        (r'^(?P<a>\w+)/b/((x|y)\w+)$',
+         r'^(?P<a>\w+)/b/<var>$',
+         'Nested unnamed group (from docstring)'),
+        (r'(\w+)',
+         r'<var>',
+         'Single unnamed group without trailing slash'),
+        (r'(\w+)/',
+         r'<var>/',
+         'Single unnamed group with trailing slash'),
+    ]
+
+    all_passed = True
+    for input_pattern, expected, description in tests:
+        result = replace_unnamed_groups(input_pattern)
+        passed = result == expected
+        all_passed = all_passed and passed
+        status = "PASS" if passed else "FAIL"
+        print(f"\n[{status}] {description}")
+        print(f"  Input:    {input_pattern}")
+        print(f"  Expected: {expected}")
+        print(f"  Got:      {result}")
+
+    return all_passed
+
+
+if __name__ == '__main__':
+    named_passed = test_replace_named_groups()
+    unnamed_passed = test_replace_unnamed_groups()
+
+    print("\n" + "=" * 60)
+    print("SUMMARY")
+    print("=" * 60)
+    print(f"replace_named_groups:  {'ALL TESTS PASSED' if named_passed else 'SOME TESTS FAILED'}")
+    print(f"replace_unnamed_groups: {'ALL TESTS PASSED' if unnamed_passed else 'SOME TESTS FAILED'}")
+
+    if named_passed and unnamed_passed:
+        print("\nAll tests passed!")
+        exit(0)
+    else:
+        print("\nSome tests failed!")
+        exit(1)
diff --git a/test_original.py b/test_original.py
new file mode 100644
index 0000000000..2706a28b7a
--- /dev/null
+++ b/test_original.py
@@ -0,0 +1,65 @@
+import re
+
+unnamed_group_matcher = re.compile(r'\(')
+
+def replace_unnamed_groups(pattern):
+    unnamed_group_indices = [m.start(0) for m in unnamed_group_matcher.finditer(pattern)]
+    group_indices = []
+    for start in unnamed_group_indices:
+        unmatched_open_brackets, prev_char = 1, None
+        for idx, val in enumerate(pattern[start + 1:]):
+            if unmatched_open_brackets == 0:
+                group_indices.append((start, start + 1 + idx))
+                break
+
+            if val == '(' and prev_char != '\\':
+                unmatched_open_brackets += 1
+            elif val == ')' and prev_char != '\\':
+                unmatched_open_brackets -= 1
+            prev_char = val
+
+    group_start_end_indices = []
+    prev_end = None
+    for start, end in group_indices:
+        if prev_end and start > prev_end or not prev_end:
+            group_start_end_indices.append((start, end))
+        prev_end = end
+
+    if group_start_end_indices:
+        final_pattern, prev_end = [], None
+        for start, end in group_start_end_indices:
+            if prev_end:
+                final_pattern.append(pattern[prev_end:start])
+            final_pattern.append(pattern[:start] + '<var>')
+            prev_end = end
+        final_pattern.append(pattern[prev_end:])
+        return ''.join(final_pattern)
+    else:
+        return pattern
+
+# Test from docstring
+print("=" * 60)
+print("Testing ORIGINAL replace_unnamed_groups")
+print("=" * 60)
+
+pattern1 = r'^(?P<a>\w+)/b/(\w+)$'
+result1 = replace_unnamed_groups(pattern1)
+print(f'Input:   {pattern1}')
+print(f'Result:  {result1}')
+print(f'Expected: ^(?P<a>\w+)/b/<var>$')
+print()
+
+# Test simple case
+pattern2 = r'(\w+)'
+result2 = replace_unnamed_groups(pattern2)
+print(f'Input:   {pattern2}')
+print(f'Result:  {result2}')
+print(f'Expected: <var>')
+print()
+
+# Test simple case with trailing slash
+pattern3 = r'(\w+)/'
+result3 = replace_unnamed_groups(pattern3)
+print(f'Input:   {pattern3}')
+print(f'Result:  {result3}')
+print(f'Expected: <var>/')
diff --git a/test_reproduce.py b/test_reproduce.py
new file mode 100644
index 0000000000..631703d241
--- /dev/null
+++ b/test_reproduce.py
@@ -0,0 +1,74 @@
+import re
+
+named_group_matcher = re.compile(r'\(\?P(<\w+>)')
+
+def replace_named_groups(pattern):
+    r'''
+    Find named groups in `pattern` and replace them with the group name. E.g.,
+    1. ^(?P<a>\w+)/b/(\w+)$ ==> ^<a>/b/(\w+)$
+    2. ^(?P<a>\w+)/b/(?P<c>\w+)/$ ==> ^<a>/b/<c>/$
+    '''
+    named_group_indices = [
+        (m.start(0), m.end(0), m.group(1))
+        for m in named_group_matcher.finditer(pattern)
+    ]
+    # Tuples of (named capture group pattern, group name).
+    group_pattern_and_name = []
+    # Loop over the groups and their start and end indices.
+    for start, end, group_name in named_group_indices:
+        # Handle nested parentheses, e.g. '^(?P<a>(x|y))/b'.
+        unmatched_open_brackets, prev_char = 1, None
+        for idx, val in enumerate(pattern[end:]):
+            # If brackets are balanced, the end of the string for the current
+            # named capture group pattern has been reached.
+            if unmatched_open_brackets == 0:
+                group_pattern_and_name.append((pattern[start:end + idx], group_name))
+                break
+
+            # Check for unescaped `(` and `)`. They mark the start and end of a
+            # nested group.
+            if val == '(' and prev_char != '\\':
+                unmatched_open_brackets += 1
+            elif val == ')' and prev_char != '\\':
+                unmatched_open_brackets -= 1
+            prev_char = val
+
+    # Replace the string for named capture groups with their group names.
+    for group_pattern, group_name in group_pattern_and_name:
+        pattern = pattern.replace(group_pattern, group_name)
+    return pattern
+
+# Test case from issue
+print("=" * 60)
+print("Test 1: Pattern WITHOUT trailing slash (buggy case)")
+print("=" * 60)
+pattern1 = r'entries/(?P<pk>[^/.]+)/relationships/(?P<related_field>\w+)'
+result1 = replace_named_groups(pattern1)
+print(f'Input:  {pattern1}')
+print(f'Result: {result1}')
+print(f'Expected: entries/<pk>/relationships/<related_field>')
+print(f'Match: {result1 == "entries/<pk>/relationships/<related_field>"}')
+print()
+
+# Test with trailing slash - should work
+print("=" * 60)
+print("Test 2: Pattern WITH trailing slash (workaround)")
+print("=" * 60)
+pattern2 = r'entries/(?P<pk>[^/.]+)/relationships/(?P<related_field>\w+)/'
+result2 = replace_named_groups(pattern2)
+print(f'Input:  {pattern2}')
+print(f'Result: {result2}')
+print(f'Expected: entries/<pk>/relationships/<related_field>/')
+print(f'Match: {result2 == "entries/<pk>/relationships/<related_field>/"}')
+print()
+
+# Simpler test
+print("=" * 60)
+print("Test 3: Simple pattern without trailing slash")
+print("=" * 60)
+pattern3 = r'(?P<id>\w+)'
+result3 = replace_named_groups(pattern3)
+print(f'Input:  {pattern3}')
+print(f'Result: {result3}')
+print(f'Expected: <id>')
+print(f'Match: {result3 == "<id>"}')
