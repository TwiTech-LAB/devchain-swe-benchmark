{
  "instance_id": "sphinx-doc__sphinx-7985",
  "status": "completed",
  "patch": "diff --git a/sphinx/builders/linkcheck.py b/sphinx/builders/linkcheck.py\nindex dd5317087..bf90f73af 100644\n--- a/sphinx/builders/linkcheck.py\n+++ b/sphinx/builders/linkcheck.py\n@@ -109,6 +109,49 @@ class CheckExternalLinksBuilder(Builder):\n             thread.start()\n             self.workers.append(thread)\n \n+    def check_internal(self, uri: str, docname: str) -> Tuple[str, str, int]:\n+        \"\"\"Check if an internal/local reference target exists.\n+\n+        Returns the status tuple (status, info, code) for the internal link.\n+        \"\"\"\n+        # Split off anchor if present\n+        if '#' in uri:\n+            base_uri, _anchor = uri.split('#', 1)\n+        else:\n+            base_uri = uri\n+            _anchor = None\n+\n+        # Check if it's a valid document\n+        if base_uri in self.env.all_docs:\n+            # Valid document\n+            return 'working', '', 0\n+\n+        # Check if it's a known reference target in the standard domain\n+        std_domain = self.env.get_domain('std')\n+        # Check labels (named reference targets)\n+        if base_uri in std_domain.labels:\n+            return 'working', '', 0\n+        # Check anonlabels (anonymous reference targets)\n+        if base_uri in std_domain.anonlabels:\n+            return 'working', '', 0\n+\n+        # Check objects (glossary terms, tokens, etc.)\n+        for objtype, name in std_domain.objects:\n+            if name == base_uri:\n+                return 'working', '', 0\n+\n+        # Check if it's a relative path to an existing document\n+        # Handle cases like 'subdir/document' or 'document'\n+        # Try to resolve relative to current document\n+        if '/' in base_uri or '\\\\' in base_uri:\n+            # Might be a relative path - check if file exists\n+            docuri = path.join(path.dirname(self.env.doc2path(docname)), base_uri)\n+            if path.exists(path.join(self.env.srcdir, docuri)):\n+                return 'working', '', 0\n+\n+        # Not found - it's a broken internal link\n+        return 'broken', __('undefined label: %s') % base_uri, 0\n+\n     def check_thread(self) -> None:\n         kwargs = {\n             'allow_redirects': True,\n@@ -213,7 +256,9 @@ class CheckExternalLinksBuilder(Builder):\n             if len(uri) == 0 or uri.startswith(('#', 'mailto:', 'ftp:')):\n                 return 'unchecked', '', 0\n             elif not uri.startswith(('http:', 'https:')):\n-                return 'local', '', 0\n+                # Check if the local/internal link exists\n+                # Try to resolve the reference against known targets\n+                return self.check_internal(uri, docname)\n             elif uri in self.good:\n                 return 'working', 'old', 0\n             elif uri in self.broken:\ndiff --git a/tox.ini b/tox.ini\nindex bddd822a6..34baee205 100644\n--- a/tox.ini\n+++ b/tox.ini\n@@ -27,7 +27,7 @@ extras =\n setenv =\n     PYTHONWARNINGS = all,ignore::ImportWarning:importlib._bootstrap_external,ignore::DeprecationWarning:site,ignore::DeprecationWarning:distutils\n commands=\n-    pytest --durations 25 {posargs}\n+    pytest -rA --durations 25 {posargs}\n \n [testenv:flake8]\n basepython = python3\n",
  "epics_created": 1,
  "epics_completed": 1,
  "start_time": "2026-01-31T20:57:24.875389",
  "end_time": "2026-01-31T21:17:58.585933",
  "duration_seconds": 1233.710544,
  "error_message": null,
  "workspace_path": "<redacted>",
  "epic_comments": [
    {
      "epic_id": "a7626f12-9c4b-48ec-9580-d633521f8d0d",
      "epic_title": "Fix: sphinx-doc__sphinx-7985",
      "comment_id": "d2ba3b86-8839-4c7c-a44e-5e671032f556",
      "author_name": "Brainstormer",
      "content": "## Fix Summary\n\nAdded validation for local/internal links in the linkcheck builder. Previously, links like `.. _local-link: doesntexist` were simply marked as 'local' without checking if the target exists.\n\n## Files Modified\n- `sphinx/builders/linkcheck.py`:\n  - Added `check_internal()` method (lines 112-153) to validate internal/local references\n  - Modified `check()` function to call `check_internal()` for non-HTTP URIs (lines 258-261)\n\n## Implementation Details\n\nThe `check_internal()` method validates local URIs by checking:\n1. If the URI is a valid document in `env.all_docs`\n2. If the URI is in the StandardDomain's `labels` (named reference targets)\n3. If the URI is in the StandardDomain's `anonlabels` (anonymous reference targets)\n4. If the URI is in the StandardDomain's `objects` (glossary terms, tokens, etc.)\n5. If the URI is a relative path to an existing file\n\nIf none of these checks pass, the link is reported as broken with the message \"undefined label: {uri}\".\n\n## Test Results\n- **Test file:** tests/test_build_linkcheck.py\n- **Baseline (before fix):** 5 passed\n- **After fix:** 5 passed\n- **Regression check:** No new failures introduced\n\n## Additional Verification\n\nTested the exact case from the issue:\n```rst\nbroken external-link_\nbroken local-link_\n\n.. _external-link: https://lkfqhlkghflkhs\n.. _local-link: doesntexist\n```\n\n**Before fix:**\n- `doesntexist` was marked as `[local]` (not checked)\n\n**After fix:**\n- `doesntexist` is marked as `[broken]` with \"undefined label: doesntexist\"\n\n## Concerns\nNone - the fix is minimal and focused on the specific issue.",
      "created_at": "2026-01-31T20:17:39.840Z"
    }
  ]
}