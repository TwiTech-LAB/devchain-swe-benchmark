{
  "instance_id": "django__django-14170",
  "status": "completed",
  "patch": "diff --git a/django/db/models/functions/datetime.py b/django/db/models/functions/datetime.py\nindex 90e6f41be0..bbe9fa8c79 100644\n--- a/django/db/models/functions/datetime.py\n+++ b/django/db/models/functions/datetime.py\n@@ -164,12 +164,6 @@ ExtractYear.register_lookup(YearGte)\n ExtractYear.register_lookup(YearLt)\n ExtractYear.register_lookup(YearLte)\n \n-ExtractIsoYear.register_lookup(YearExact)\n-ExtractIsoYear.register_lookup(YearGt)\n-ExtractIsoYear.register_lookup(YearGte)\n-ExtractIsoYear.register_lookup(YearLt)\n-ExtractIsoYear.register_lookup(YearLte)\n-\n \n class Now(Func):\n     template = 'CURRENT_TIMESTAMP'\ndiff --git a/simple_verify.py b/simple_verify.py\nnew file mode 100644\nindex 0000000000..1d75d82dd8\n--- /dev/null\n+++ b/simple_verify.py\n@@ -0,0 +1,64 @@\n+#!/usr/bin/env python\n+\"\"\"\n+Simple verification that ExtractIsoYear no longer has YearLookup registrations.\n+\"\"\"\n+import sys\n+sys.path.insert(0, '/testbed')\n+\n+from django.db.models.functions.datetime import ExtractIsoYear, ExtractYear\n+from django.db.models.lookups import YearExact, YearGt, YearGte, YearLt, YearLte\n+\n+print(\"=\" * 60)\n+print(\"Verifying fix for django__django-14170\")\n+print(\"=\" * 60)\n+\n+# Check the registered lookups on ExtractIsoYear\n+print(\"\\n1. Checking lookups registered on ExtractIsoYear:\")\n+iso_year_lookups = ExtractIsoYear.get_lookups()\n+print(f\"   Registered lookups: {list(iso_year_lookups.keys())}\")\n+\n+# Check if YearLookup classes are registered\n+year_lookup_names = ['exact', 'gt', 'gte', 'lt', 'lte']\n+year_lookup_classes = [YearExact, YearGt, YearGte, YearLt, YearLte]\n+\n+registered_but_should_not = []\n+for cls in year_lookup_classes:\n+    lookup_name = cls.lookup_name if hasattr(cls, 'lookup_name') else None\n+    if lookup_name and lookup_name in iso_year_lookups:\n+        if iso_year_lookups[lookup_name] == cls:\n+            registered_but_should_not.append((lookup_name, cls.__name__))\n+\n+if registered_but_should_not:\n+    print(f\"   ERROR: The following YearLookup classes are incorrectly registered on ExtractIsoYear:\")\n+    for name, cls in registered_but_should_not:\n+        print(f\"     - {cls} (lookup_name: {name})\")\n+else:\n+    print(f\"   CORRECT: No YearLookup classes (YearExact, YearGt, etc.) are registered on ExtractIsoYear\")\n+\n+# Check ExtractYear still has them\n+print(\"\\n2. Checking lookups registered on ExtractYear (should have YearLookup):\")\n+year_lookups = ExtractYear.get_lookups()\n+print(f\"   Registered lookups: {list(year_lookups.keys())}\")\n+\n+registered_year_lookups = []\n+for cls in year_lookup_classes:\n+    lookup_name = cls.lookup_name if hasattr(cls, 'lookup_name') else None\n+    if lookup_name and lookup_name in year_lookups:\n+        if year_lookups[lookup_name] == cls:\n+            registered_year_lookups.append((lookup_name, cls.__name__))\n+\n+if registered_year_lookups:\n+    print(f\"   CORRECT: YearLookup classes are properly registered on ExtractYear:\")\n+    for name, cls in registered_year_lookups:\n+        print(f\"     - {cls} (lookup_name: {name})\")\n+else:\n+    print(f\"   ERROR: YearLookup classes are missing from ExtractYear\")\n+\n+print(\"\\n\" + \"=\" * 60)\n+if not registered_but_should_not and registered_year_lookups:\n+    print(\"SUCCESS: Fix is correctly applied!\")\n+    print(\"  - ExtractIsoYear does NOT have YearLookup registrations\")\n+    print(\"  - ExtractYear DOES have YearLookup registrations\")\n+else:\n+    print(\"FAILURE: Fix not correctly applied!\")\n+print(\"=\" * 60)\ndiff --git a/verify_fix.py b/verify_fix.py\nnew file mode 100644\nindex 0000000000..ac9e8a850d\n--- /dev/null\n+++ b/verify_fix.py\n@@ -0,0 +1,101 @@\n+#!/usr/bin/env python\n+\"\"\"\n+Verification script for django__django-14170 fix.\n+\n+This script demonstrates that the iso_year lookup now correctly uses EXTRACT\n+instead of BETWEEN after removing the YearLookup registrations from ExtractIsoYear.\n+\"\"\"\n+import os\n+import sys\n+import django\n+\n+# Setup Django\n+sys.path.insert(0, '/testbed')\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tests.db_functions.settings')\n+django.setup()\n+\n+from datetime import datetime\n+from django.db.models.functions import ExtractIsoYear, ExtractYear\n+from tests.db_functions.models import DTModel\n+\n+# Clear any existing data\n+DTModel.objects.all().delete()\n+\n+# Create test data with ISO year boundary cases\n+# Dec 31, 2014 is in ISO week 1 of 2015\n+week_1_day_2014_2015 = datetime(2014, 12, 31, 13, 0)\n+# Dec 31, 2015 is in ISO week 53 of 2015\n+week_53_day_2015 = datetime(2015, 12, 31, 13, 0)\n+# A normal day in 2015\n+normal_day_2015 = datetime(2015, 6, 15, 14, 10)\n+\n+DTModel.objects.create(name='dec31_2014', start_datetime=week_1_day_2014_2015, end_datetime=normal_day_2015)\n+DTModel.objects.create(name='dec31_2015', start_datetime=week_53_day_2015, end_datetime=normal_day_2015)\n+DTModel.objects.create(name='jun15_2015', start_datetime=normal_day_2015, end_datetime=week_1_day_2014_2015)\n+\n+print(\"=\" * 60)\n+print(\"Test Data Created:\")\n+print(\"  - 2014-12-31 (ISO year 2015)\")\n+print(\"  - 2015-12-31 (ISO year 2015)\")\n+print(\"  - 2015-06-15 (ISO year 2015)\")\n+print(\"=\" * 60)\n+\n+# Test 1: Check that ExtractIsoYear annotation works correctly\n+print(\"\\n1. Testing ExtractIsoYear annotation (should work):\")\n+qs = DTModel.objects.annotate(\n+    extracted=ExtractIsoYear('start_datetime')\n+).order_by('start_datetime')\n+for obj in qs:\n+    print(f\"   {obj.start_datetime.date()} -> ISO year: {obj.extracted}\")\n+\n+# Test 2: Check the SQL generated for iso_year lookup\n+print(\"\\n2. SQL generated for iso_year=2015 lookup:\")\n+qs = DTModel.objects.filter(start_datetime__iso_year=2015)\n+sql = str(qs.query)\n+print(f\"   {sql}\")\n+if 'BETWEEN' in sql.upper():\n+    print(\"   ERROR: Still using BETWEEN (incorrect for ISO year!)\")\n+elif 'EXTRACT' in sql.upper() or 'extract' in sql.lower():\n+    print(\"   CORRECT: Using EXTRACT for ISO year lookup\")\n+else:\n+    print(f\"   INFO: SQL doesn't contain BETWEEN or EXTRACT\")\n+\n+# Test 3: Check the SQL generated for year lookup (should still use BETWEEN)\n+print(\"\\n3. SQL generated for year=2015 lookup (should use BETWEEN):\")\n+qs = DTModel.objects.filter(start_datetime__year=2015)\n+sql = str(qs.query)\n+print(f\"   {sql}\")\n+if 'BETWEEN' in sql.upper():\n+    print(\"   CORRECT: Using BETWEEN for calendar year lookup\")\n+else:\n+    print(\"   INFO: Not using BETWEEN\")\n+\n+# Test 4: Verify correct results with ISO year filtering\n+print(\"\\n4. Testing ISO year filtering correctness:\")\n+qs = DTModel.objects.filter(start_datetime__iso_year=2015).order_by('start_datetime')\n+print(f\"   Found {qs.count()} records with iso_year=2015\")\n+for obj in qs:\n+    print(f\"   - {obj.start_datetime.date()} (name: {obj.name})\")\n+\n+# All three dates should be in ISO year 2015\n+expected_count = 3\n+if qs.count() == expected_count:\n+    print(f\"   CORRECT: Found all {expected_count} dates in ISO year 2015\")\n+else:\n+    print(f\"   ERROR: Expected {expected_count} dates, found {qs.count()}\")\n+\n+# Test 5: Verify annotation used in filter\n+print(\"\\n5. Testing annotation used in filter:\")\n+qs = DTModel.objects.annotate(\n+    extracted=ExtractIsoYear('start_datetime')\n+).filter(extracted=2015)\n+sql = str(qs.query)\n+print(f\"   SQL: {sql}\")\n+if 'BETWEEN' in sql.upper():\n+    print(\"   WARNING: Using BETWEEN even with annotation\")\n+else:\n+    print(\"   CORRECT: Not using BETWEEN with annotation\")\n+\n+print(\"\\n\" + \"=\" * 60)\n+print(\"Verification complete!\")\n+print(\"=\" * 60)\n",
  "epics_created": 1,
  "epics_completed": 1,
  "start_time": "2026-01-31T17:29:46.124996",
  "end_time": "2026-01-31T17:36:48.165820",
  "duration_seconds": 422.040824,
  "error_message": null,
  "workspace_path": "<redacted>",
  "epic_comments": [
    {
      "epic_id": "1524e9c7-6238-456c-8e77-9f351e84dc75",
      "epic_title": "Fix: django__django-14170",
      "comment_id": "8a1f27c0-f59d-4b84-9223-6fd9773c6586",
      "author_name": "Brainstormer",
      "content": "## Fix Summary\n\nThe bug was that `ExtractIsoYear` incorrectly registered `YearLookup` classes (`YearExact`, `YearGt`, `YearGte`, `YearLt`, `YearLte`). These lookups use a BETWEEN optimization with calendar year bounds (Jan 1 to Dec 31), but ISO-8601 year has different boundaries (can start on Dec 29 of previous year or end on Jan 2 of next year).\n\nThe fix removes the invalid YearLookup registrations from `ExtractIsoYear` so that `__iso_year` lookups will use the default `EXTRACT` SQL operation instead of the incorrect BETWEEN optimization.\n\n## Files Modified\n\n- `django/db/models/functions/datetime.py`: Removed lines 167-171 that registered YearExact, YearGt, YearGte, YearLt, YearLte on ExtractIsoYear\n\n## Verification Results\n\nRan verification script in container:\n- ExtractIsoYear no longer has YearLookup registrations (CORRECT)\n- ExtractYear still has YearLookup registrations (CORRECT)\n\nThe fix ensures:\n1. `field__year=2020` still uses `BETWEEN 2020-01-01 AND 2020-12-31` (correct for calendar year)\n2. `field__iso_year=2020` now uses `EXTRACT(isoyear FROM field)` (correct for ISO year)\n3. ExtractIsoYear annotations continue to work correctly",
      "created_at": "2026-01-31T16:36:38.812Z"
    }
  ]
}