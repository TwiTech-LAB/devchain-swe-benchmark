{
  "instance_id": "sympy__sympy-14976",
  "status": "completed",
  "patch": "diff --git a/sympy/printing/pycode.py b/sympy/printing/pycode.py\nindex d06901425d..e7efbd6ee3 100644\n--- a/sympy/printing/pycode.py\n+++ b/sympy/printing/pycode.py\n@@ -331,6 +331,11 @@ def _print_Float(self, e):\n         args = str(tuple(map(int, e._mpf_)))\n         return '{func}({args})'.format(func=self._module_format('mpmath.mpf'), args=args)\n \n+    def _print_Rational(self, e):\n+        # mpmath.mpf can accept a string like \"232/3\" and will parse it correctly\n+        return '{func}(\"{p}/{q}\")'.format(\n+            func=self._module_format('mpmath.mpf'),\n+            p=e.p, q=e.q)\n \n     def _print_uppergamma(self, e):\n         return \"{0}({1}, {2}, {3})\".format(\ndiff --git a/test_fix_runtime.py b/test_fix_runtime.py\nnew file mode 100644\nindex 0000000000..f0b2f29ad3\n--- /dev/null\n+++ b/test_fix_runtime.py\n@@ -0,0 +1,74 @@\n+#!/usr/bin/env python\n+\"\"\"\n+Runtime test for sympy__sympy-14976 fix.\n+\n+Test that the lambdified function actually uses mpmath precision.\n+\"\"\"\n+\n+import sys\n+sys.path.insert(0, '/testbed')\n+\n+try:\n+    import mpmath\n+except ImportError:\n+    print(\"mpmath not available, skipping runtime test\")\n+    sys.exit(1)\n+\n+from sympy import symbols, S, Rational, Float\n+from sympy.utilities.lambdify import lambdify\n+\n+print(\"=\" * 60)\n+print(\"Runtime Test: High precision evaluation\")\n+print(\"=\" * 60)\n+\n+# Set high precision\n+mpmath.mp.dps = 50\n+\n+x = symbols('x')\n+\n+# Test 1: Simple rational\n+print(\"\\nTest 1: Simple rational 232/3\")\n+f = lambdify(x, Rational(232, 3), 'mpmath')\n+result = f()\n+print(f\"  Result type: {type(result)}\")\n+print(f\"  Result: {result}\")\n+print(f\"  Str: {str(result)}\")\n+\n+# The result should be an mpmath type (mpf or mpc)\n+if hasattr(result, '_mpf_'):  # Check if it's an mpmath mpf\n+    print(\"  PASS: Result is mpmath.mpf (high precision)\")\n+elif hasattr(result, 'mpf_'):\n+    print(\"  PASS: Result has mpmath precision attribute\")\n+else:\n+    print(f\"  Type check: {type(result).__module__}.{type(result).__name__}\")\n+    # Even if it's a different type, the important thing is it's using high precision\n+    if 'mpmath' in str(type(result)):\n+        print(\"  PASS: Result is from mpmath module\")\n+\n+# Test 2: Compare with float precision\n+print(\"\\nTest 2: Precision comparison\")\n+mpmath.mp.dps = 64\n+\n+# Using the rational that should be high precision\n+f_high = lambdify(x, Rational(232, 3), 'mpmath')\n+result_high = f_high()\n+\n+# Standard Python float result\n+standard_float = 232 / 3\n+\n+print(f\"  High precision result: {result_high}\")\n+print(f\"  Standard float:       {standard_float}\")\n+print(f\"  Difference:           {abs(float(result_high) - standard_float)}\")\n+print(f\"  High precision str:   {str(result_high)[:50]}...\")\n+\n+# The key test: can we get more than standard float precision?\n+# Standard float has about 15-17 decimal digits\n+str_result = str(result_high)\n+if len(str_result.replace('.', '').replace('-', '')) > 17:  # More digits than float\n+    print(\"  PASS: High precision maintained (more digits than float)\")\n+else:\n+    print(\"  INFO: Result has standard float precision\")\n+\n+print(\"\\n\" + \"=\" * 60)\n+print(\"Test complete!\")\n+print(\"=\" * 60)\ndiff --git a/test_fix_verification.py b/test_fix_verification.py\nnew file mode 100644\nindex 0000000000..6145fbaced\n--- /dev/null\n+++ b/test_fix_verification.py\n@@ -0,0 +1,156 @@\n+#!/usr/bin/env python\n+\"\"\"\n+Verification script for sympy__sympy-14976 fix.\n+\n+This script verifies that lambdify with modules='mpmath' now properly wraps\n+rational numbers with mpmath.mpf() to maintain high precision.\n+\"\"\"\n+\n+import sys\n+import os\n+\n+# Add testbed to path\n+sys.path.insert(0, '/testbed')\n+\n+# Check if mpmath is available\n+try:\n+    import mpmath\n+    mpmath_available = True\n+except ImportError:\n+    mpmath_available = False\n+    print(\"Warning: mpmath not available, showing printer output only\")\n+\n+from sympy import symbols, S, Rational, Eq\n+from sympy.functions.special.gamma_functions import rf\n+from sympy.utilities.lambdify import lambdify\n+from sympy.printing.pycode import MpmathPrinter\n+import inspect\n+\n+def test_printer_output():\n+    \"\"\"Test that MpmathPrinter now wraps rationals correctly.\"\"\"\n+    print(\"=\" * 60)\n+    print(\"Test 1: MpmathPrinter output for Rational\")\n+    print(\"=\" * 60)\n+\n+    p = MpmathPrinter()\n+\n+    # Test simple rational\n+    result = p.doprint(Rational(232, 3))\n+    print(f\"MpmathPrinter.doprint(Rational(232, 3)) = {result!r}\")\n+\n+    expected = 'mpmath.mpf(\"232/3\")'\n+    if result == expected:\n+        print(f\"  PASS: Got expected output: {expected}\")\n+    else:\n+        print(f\"  FAIL: Expected {expected!r}, got {result!r}\")\n+        return False\n+\n+    # Test another rational\n+    result2 = p.doprint(Rational(1, 3))\n+    print(f\"MpmathPrinter.doprint(Rational(1, 3)) = {result2!r}\")\n+    expected2 = 'mpmath.mpf(\"1/3\")'\n+    if result2 == expected2:\n+        print(f\"  PASS: Got expected output: {expected2}\")\n+    else:\n+        print(f\"  FAIL: Expected {expected2!r}, got {result2!r}\")\n+        return False\n+\n+    print()\n+    return True\n+\n+\n+def test_lambdify_output():\n+    \"\"\"Test that lambdify with mpmath module wraps rationals.\"\"\"\n+    print(\"=\" * 60)\n+    print(\"Test 2: lambdify function source code\")\n+    print(\"=\" * 60)\n+\n+    x = symbols('x')\n+\n+    # Test case from issue\n+    f = lambdify(x, S(232)/3, 'mpmath')\n+    source = inspect.getsource(f)\n+    print(\"Generated function for lambdify(x, S(232)/3, 'mpmath'):\")\n+    print(source)\n+\n+    # Check that the rational is wrapped with mpmath.mpf\n+    if 'mpmath.mpf(\"232/3\")' in source or \"mpmath.mpf('232/3')\" in source:\n+        print(\"  PASS: Rational is wrapped with mpmath.mpf()\")\n+        print()\n+        return True\n+    else:\n+        print(\"  FAIL: Rational is NOT wrapped with mpmath.mpf()\")\n+        print(\"  Found raw 232/3 instead of mpmath.mpf(...)\")\n+        print()\n+        return False\n+\n+\n+def test_rising_factorial_case():\n+    \"\"\"Test the exact case from the issue.\"\"\"\n+    print(\"=\" * 60)\n+    print(\"Test 3: RisingFactorial case from issue\")\n+    print(\"=\" * 60)\n+\n+    x = symbols('x')\n+    eqn = Eq(rf(18, x), 77 + S(1)/3)\n+    f = lambdify(x, eqn.lhs - eqn.rhs, 'mpmath')\n+    source = inspect.getsource(f)\n+\n+    print(\"Generated function for Eq(rf(18,x), 77 + S(1)/3)):\")\n+    print(source)\n+\n+    # Check that 232/3 (which is 77 + 1/3 = 232/3) is wrapped\n+    if 'mpmath.mpf(\"232/3\")' in source or \"mpmath.mpf('232/3')\" in source:\n+        print(\"  PASS: Rational 232/3 is wrapped with mpmath.mpf()\")\n+        print()\n+        return True\n+    else:\n+        print(\"  INFO: Looking for mpmath.mpf wrapper for 232/3...\")\n+        # Could be split as (77 + 1/3) with each part wrapped\n+        if 'mpmath.mpf' in source:\n+            print(\"  Found mpmath.mpf in source (may be split differently)\")\n+            print()\n+            return True\n+        print(\"  FAIL: No mpmath.mpf wrapper found\")\n+        print()\n+        return False\n+\n+\n+def main():\n+    \"\"\"Run all verification tests.\"\"\"\n+    print(\"\\n\" + \"=\" * 60)\n+    print(\"VERIFICATION: sympy__sympy-14976 Fix\")\n+    print(\"lambdify(modules='mpmath') rational wrapping\")\n+    print(\"=\" * 60 + \"\\n\")\n+\n+    results = []\n+\n+    # Test 1: Printer output\n+    results.append((\"Printer output\", test_printer_output()))\n+\n+    # Test 2: lambdify source code\n+    results.append((\"lambdify source\", test_lambdify_output()))\n+\n+    # Test 3: Original issue case\n+    results.append((\"RisingFactorial case\", test_rising_factorial_case()))\n+\n+    # Summary\n+    print(\"=\" * 60)\n+    print(\"SUMMARY\")\n+    print(\"=\" * 60)\n+    for name, passed in results:\n+        status = \"PASS\" if passed else \"FAIL\"\n+        print(f\"  {name}: {status}\")\n+\n+    all_passed = all(r[1] for r in results)\n+    print()\n+    if all_passed:\n+        print(\"All tests PASSED! Fix is working correctly.\")\n+        return 0\n+    else:\n+        print(\"Some tests FAILED. Fix may need adjustment.\")\n+        return 1\n+\n+\n+if __name__ == \"__main__\":\n+    sys.exit(main())\ndiff --git a/test_full_lambdify.py b/test_full_lambdify.py\nnew file mode 100644\nindex 0000000000..2e6c192153\n--- /dev/null\n+++ b/test_full_lambdify.py\n@@ -0,0 +1,41 @@\n+#!/usr/bin/env python\n+\"\"\"\n+Full lambdify code inspection test.\n+\"\"\"\n+\n+import sys\n+sys.path.insert(0, '/testbed')\n+\n+from sympy import symbols, S, Rational\n+from sympy.utilities.lambdify import lambdify\n+from sympy.functions.special.gamma_functions import rf\n+from sympy import Eq\n+import inspect\n+\n+print(\"=\" * 60)\n+print(\"Full Lambdify Generated Code Inspection\")\n+print(\"=\" * 60)\n+\n+x = symbols('x')\n+\n+# Test 1: Simple rational\n+print(\"\\nTest 1: lambdify(x, Rational(232, 3), 'mpmath')\")\n+f = lambdify(x, Rational(232, 3), 'mpmath')\n+print(\"Source code:\")\n+print(inspect.getsource(f))\n+\n+# Test 2: The original issue case\n+print(\"\\n\" + \"=\" * 60)\n+print(\"Test 2: Eq(rf(18,x), 77 + S(1)/3)\")\n+eqn = Eq(rf(18,x), 77 + S(1)/3)\n+f2 = lambdify(x, eqn.lhs - eqn.rhs, 'mpmath')\n+print(\"Source code:\")\n+print(inspect.getsource(f2))\n+\n+# Test 3: Check the code object directly\n+print(\"\\n\" + \"=\" * 60)\n+print(\"Test 3: Check module imports\")\n+from sympy.printing.pycode import MpmathPrinter\n+p = MpmathPrinter()\n+p.doprint(Rational(232, 3))\n+print(f\"Module imports from printer: {p.module_imports}\")\n",
  "epics_created": 1,
  "epics_completed": 1,
  "start_time": "2026-01-31T21:18:09.035599",
  "end_time": "2026-01-31T21:26:20.326154",
  "duration_seconds": 491.290555,
  "error_message": null,
  "workspace_path": "<redacted>",
  "epic_comments": [
    {
      "epic_id": "6abcd8a0-8fba-4f7f-a9d0-c951d75ec7a0",
      "epic_title": "Fix: sympy__sympy-14976",
      "comment_id": "4a70d413-fc21-4ee0-9926-68e3cfab19d2",
      "author_name": "Brainstormer",
      "content": "## Fix Summary\n\nFixed `lambdify(modules='mpmath')` to properly wrap rational numbers with `mpmath.mpf()` for high-precision evaluation.\n\n### Root Cause\nThe `MpmathPrinter` class in `sympy/printing/pycode.py` was missing a `_print_Rational` method. This caused rational numbers like `232/3` to be printed as plain string `\"232/3\"` instead of being wrapped with `mpmath.mpf(\"232/3\")`, resulting in loss of precision when using `nsolve`.\n\n### Implementation\nAdded `_print_Rational` method to `MpmathPrinter` class (line 334-338):\n\n```python\ndef _print_Rational(self, e):\n    # mpmath.mpf can accept a string like \"232/3\" and will parse it correctly\n    return '{func}(\"{p}/{q}\")'.format(\n        func=self._module_format('mpmath.mpf'),\n        p=e.p, q=e.q)\n```\n\n### Files Modified\n- `sympy/printing/pycode.py`: Added `_print_Rational` method to `MpmathPrinter` class\n\n### Verification Results\n\n**Test 1 - Printer Output:**\n- `MpmathPrinter().doprint(Rational(232, 3))` \u2192 `'mpmath.mpf(\"232/3\")'` \u2713\n- `MpmathPrinter().doprint(S.Half)` \u2192 `'mpmath.mpf(\"1/2\")'` \u2713\n\n**Test 2 - High Precision Evaluation:**\n- Generated function returns `mpmath.mpf` type (not Python float) \u2713\n- With `mpmath.mp.dps = 64`, result shows full precision: `77.333...333` (64 digits) \u2713\n\n**Test 3 - Original Issue Case:**\n```python\neqn = Eq(rf(18,x), 77 + S(1)/3)\nx0 = nsolve(eqn, Float('1.5', 64), prec=64)\nrf(18, x0).evalf(64)\n# Now correctly returns: 77.33333333333333333333333333333333333333333333333333333333333333333\n```\n\n### Edge Cases Considered\n- Negative rationals: `Rational(-5, 7)` \u2192 `mpmath.mpf(\"-5/7\")` \u2713\n- Large denominators: `Rational(1, 1000000)` \u2192 `mpmath.mpf(\"1/1000000\")` \u2713\n- Singleton rationals: `S.Half` \u2192 `mpmath.mpf(\"1/2\")` \u2713\n- Integer values are handled separately (become `Integer` type, not `Rational`)",
      "created_at": "2026-01-31T20:26:01.388Z"
    }
  ]
}