diff --git a/sympy/printing/pycode.py b/sympy/printing/pycode.py
index d06901425d..e7efbd6ee3 100644
--- a/sympy/printing/pycode.py
+++ b/sympy/printing/pycode.py
@@ -331,6 +331,11 @@ def _print_Float(self, e):
         args = str(tuple(map(int, e._mpf_)))
         return '{func}({args})'.format(func=self._module_format('mpmath.mpf'), args=args)
 
+    def _print_Rational(self, e):
+        # mpmath.mpf can accept a string like "232/3" and will parse it correctly
+        return '{func}("{p}/{q}")'.format(
+            func=self._module_format('mpmath.mpf'),
+            p=e.p, q=e.q)
 
     def _print_uppergamma(self, e):
         return "{0}({1}, {2}, {3})".format(
diff --git a/test_fix_runtime.py b/test_fix_runtime.py
new file mode 100644
index 0000000000..f0b2f29ad3
--- /dev/null
+++ b/test_fix_runtime.py
@@ -0,0 +1,74 @@
+#!/usr/bin/env python
+"""
+Runtime test for sympy__sympy-14976 fix.
+
+Test that the lambdified function actually uses mpmath precision.
+"""
+
+import sys
+sys.path.insert(0, '/testbed')
+
+try:
+    import mpmath
+except ImportError:
+    print("mpmath not available, skipping runtime test")
+    sys.exit(1)
+
+from sympy import symbols, S, Rational, Float
+from sympy.utilities.lambdify import lambdify
+
+print("=" * 60)
+print("Runtime Test: High precision evaluation")
+print("=" * 60)
+
+# Set high precision
+mpmath.mp.dps = 50
+
+x = symbols('x')
+
+# Test 1: Simple rational
+print("\nTest 1: Simple rational 232/3")
+f = lambdify(x, Rational(232, 3), 'mpmath')
+result = f()
+print(f"  Result type: {type(result)}")
+print(f"  Result: {result}")
+print(f"  Str: {str(result)}")
+
+# The result should be an mpmath type (mpf or mpc)
+if hasattr(result, '_mpf_'):  # Check if it's an mpmath mpf
+    print("  PASS: Result is mpmath.mpf (high precision)")
+elif hasattr(result, 'mpf_'):
+    print("  PASS: Result has mpmath precision attribute")
+else:
+    print(f"  Type check: {type(result).__module__}.{type(result).__name__}")
+    # Even if it's a different type, the important thing is it's using high precision
+    if 'mpmath' in str(type(result)):
+        print("  PASS: Result is from mpmath module")
+
+# Test 2: Compare with float precision
+print("\nTest 2: Precision comparison")
+mpmath.mp.dps = 64
+
+# Using the rational that should be high precision
+f_high = lambdify(x, Rational(232, 3), 'mpmath')
+result_high = f_high()
+
+# Standard Python float result
+standard_float = 232 / 3
+
+print(f"  High precision result: {result_high}")
+print(f"  Standard float:       {standard_float}")
+print(f"  Difference:           {abs(float(result_high) - standard_float)}")
+print(f"  High precision str:   {str(result_high)[:50]}...")
+
+# The key test: can we get more than standard float precision?
+# Standard float has about 15-17 decimal digits
+str_result = str(result_high)
+if len(str_result.replace('.', '').replace('-', '')) > 17:  # More digits than float
+    print("  PASS: High precision maintained (more digits than float)")
+else:
+    print("  INFO: Result has standard float precision")
+
+print("\n" + "=" * 60)
+print("Test complete!")
+print("=" * 60)
diff --git a/test_fix_verification.py b/test_fix_verification.py
new file mode 100644
index 0000000000..6145fbaced
--- /dev/null
+++ b/test_fix_verification.py
@@ -0,0 +1,156 @@
+#!/usr/bin/env python
+"""
+Verification script for sympy__sympy-14976 fix.
+
+This script verifies that lambdify with modules='mpmath' now properly wraps
+rational numbers with mpmath.mpf() to maintain high precision.
+"""
+
+import sys
+import os
+
+# Add testbed to path
+sys.path.insert(0, '/testbed')
+
+# Check if mpmath is available
+try:
+    import mpmath
+    mpmath_available = True
+except ImportError:
+    mpmath_available = False
+    print("Warning: mpmath not available, showing printer output only")
+
+from sympy import symbols, S, Rational, Eq
+from sympy.functions.special.gamma_functions import rf
+from sympy.utilities.lambdify import lambdify
+from sympy.printing.pycode import MpmathPrinter
+import inspect
+
+def test_printer_output():
+    """Test that MpmathPrinter now wraps rationals correctly."""
+    print("=" * 60)
+    print("Test 1: MpmathPrinter output for Rational")
+    print("=" * 60)
+
+    p = MpmathPrinter()
+
+    # Test simple rational
+    result = p.doprint(Rational(232, 3))
+    print(f"MpmathPrinter.doprint(Rational(232, 3)) = {result!r}")
+
+    expected = 'mpmath.mpf("232/3")'
+    if result == expected:
+        print(f"  PASS: Got expected output: {expected}")
+    else:
+        print(f"  FAIL: Expected {expected!r}, got {result!r}")
+        return False
+
+    # Test another rational
+    result2 = p.doprint(Rational(1, 3))
+    print(f"MpmathPrinter.doprint(Rational(1, 3)) = {result2!r}")
+    expected2 = 'mpmath.mpf("1/3")'
+    if result2 == expected2:
+        print(f"  PASS: Got expected output: {expected2}")
+    else:
+        print(f"  FAIL: Expected {expected2!r}, got {result2!r}")
+        return False
+
+    print()
+    return True
+
+
+def test_lambdify_output():
+    """Test that lambdify with mpmath module wraps rationals."""
+    print("=" * 60)
+    print("Test 2: lambdify function source code")
+    print("=" * 60)
+
+    x = symbols('x')
+
+    # Test case from issue
+    f = lambdify(x, S(232)/3, 'mpmath')
+    source = inspect.getsource(f)
+    print("Generated function for lambdify(x, S(232)/3, 'mpmath'):")
+    print(source)
+
+    # Check that the rational is wrapped with mpmath.mpf
+    if 'mpmath.mpf("232/3")' in source or "mpmath.mpf('232/3')" in source:
+        print("  PASS: Rational is wrapped with mpmath.mpf()")
+        print()
+        return True
+    else:
+        print("  FAIL: Rational is NOT wrapped with mpmath.mpf()")
+        print("  Found raw 232/3 instead of mpmath.mpf(...)")
+        print()
+        return False
+
+
+def test_rising_factorial_case():
+    """Test the exact case from the issue."""
+    print("=" * 60)
+    print("Test 3: RisingFactorial case from issue")
+    print("=" * 60)
+
+    x = symbols('x')
+    eqn = Eq(rf(18, x), 77 + S(1)/3)
+    f = lambdify(x, eqn.lhs - eqn.rhs, 'mpmath')
+    source = inspect.getsource(f)
+
+    print("Generated function for Eq(rf(18,x), 77 + S(1)/3)):")
+    print(source)
+
+    # Check that 232/3 (which is 77 + 1/3 = 232/3) is wrapped
+    if 'mpmath.mpf("232/3")' in source or "mpmath.mpf('232/3')" in source:
+        print("  PASS: Rational 232/3 is wrapped with mpmath.mpf()")
+        print()
+        return True
+    else:
+        print("  INFO: Looking for mpmath.mpf wrapper for 232/3...")
+        # Could be split as (77 + 1/3) with each part wrapped
+        if 'mpmath.mpf' in source:
+            print("  Found mpmath.mpf in source (may be split differently)")
+            print()
+            return True
+        print("  FAIL: No mpmath.mpf wrapper found")
+        print()
+        return False
+
+
+def main():
+    """Run all verification tests."""
+    print("\n" + "=" * 60)
+    print("VERIFICATION: sympy__sympy-14976 Fix")
+    print("lambdify(modules='mpmath') rational wrapping")
+    print("=" * 60 + "\n")
+
+    results = []
+
+    # Test 1: Printer output
+    results.append(("Printer output", test_printer_output()))
+
+    # Test 2: lambdify source code
+    results.append(("lambdify source", test_lambdify_output()))
+
+    # Test 3: Original issue case
+    results.append(("RisingFactorial case", test_rising_factorial_case()))
+
+    # Summary
+    print("=" * 60)
+    print("SUMMARY")
+    print("=" * 60)
+    for name, passed in results:
+        status = "PASS" if passed else "FAIL"
+        print(f"  {name}: {status}")
+
+    all_passed = all(r[1] for r in results)
+    print()
+    if all_passed:
+        print("All tests PASSED! Fix is working correctly.")
+        return 0
+    else:
+        print("Some tests FAILED. Fix may need adjustment.")
+        return 1
+
+
+if __name__ == "__main__":
+    sys.exit(main())
diff --git a/test_full_lambdify.py b/test_full_lambdify.py
new file mode 100644
index 0000000000..2e6c192153
--- /dev/null
+++ b/test_full_lambdify.py
@@ -0,0 +1,41 @@
+#!/usr/bin/env python
+"""
+Full lambdify code inspection test.
+"""
+
+import sys
+sys.path.insert(0, '/testbed')
+
+from sympy import symbols, S, Rational
+from sympy.utilities.lambdify import lambdify
+from sympy.functions.special.gamma_functions import rf
+from sympy import Eq
+import inspect
+
+print("=" * 60)
+print("Full Lambdify Generated Code Inspection")
+print("=" * 60)
+
+x = symbols('x')
+
+# Test 1: Simple rational
+print("\nTest 1: lambdify(x, Rational(232, 3), 'mpmath')")
+f = lambdify(x, Rational(232, 3), 'mpmath')
+print("Source code:")
+print(inspect.getsource(f))
+
+# Test 2: The original issue case
+print("\n" + "=" * 60)
+print("Test 2: Eq(rf(18,x), 77 + S(1)/3)")
+eqn = Eq(rf(18,x), 77 + S(1)/3)
+f2 = lambdify(x, eqn.lhs - eqn.rhs, 'mpmath')
+print("Source code:")
+print(inspect.getsource(f2))
+
+# Test 3: Check the code object directly
+print("\n" + "=" * 60)
+print("Test 3: Check module imports")
+from sympy.printing.pycode import MpmathPrinter
+p = MpmathPrinter()
+p.doprint(Rational(232, 3))
+print(f"Module imports from printer: {p.module_imports}")
