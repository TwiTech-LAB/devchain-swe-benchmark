{
  "instance_id": "django__django-15022",
  "status": "completed",
  "patch": "diff --git a/django/contrib/admin/options.py b/django/contrib/admin/options.py\nindex 66f3396a6b..3e51ae5855 100644\n--- a/django/contrib/admin/options.py\n+++ b/django/contrib/admin/options.py\n@@ -1031,18 +1031,39 @@ class ModelAdmin(BaseModelAdmin):\n         if search_fields and search_term:\n             orm_lookups = [construct_search(str(search_field))\n                            for search_field in search_fields]\n-            for bit in smart_split(search_term):\n-                if bit.startswith(('\"', \"'\")) and bit[0] == bit[-1]:\n-                    bit = unescape_string_literal(bit)\n-                or_queries = models.Q(\n-                    *((orm_lookup, bit) for orm_lookup in orm_lookups),\n-                    _connector=models.Q.OR,\n-                )\n-                queryset = queryset.filter(or_queries)\n-            may_have_duplicates |= any(\n+            # Check if any lookup spawns duplicates (e.g., m2m relationships)\n+            spawns_dupes = any(\n                 lookup_spawns_duplicates(self.opts, search_spec)\n                 for search_spec in orm_lookups\n             )\n+            if spawns_dupes:\n+                # For lookups that spawn duplicates, use separate filter() calls\n+                # to preserve correct semantics (each search term can match\n+                # a different related row)\n+                for bit in smart_split(search_term):\n+                    if bit.startswith(('\"', \"'\")) and bit[0] == bit[-1]:\n+                        bit = unescape_string_literal(bit)\n+                    or_queries = models.Q(\n+                        *((orm_lookup, bit) for orm_lookup in orm_lookups),\n+                        _connector=models.Q.OR,\n+                    )\n+                    queryset = queryset.filter(or_queries)\n+            else:\n+                # For lookups that don't spawn duplicates (e.g., ForeignKey),\n+                # combine all search terms into a single filter() call to avoid\n+                # creating unnecessary JOINs\n+                search_queries = []\n+                for bit in smart_split(search_term):\n+                    if bit.startswith(('\"', \"'\")) and bit[0] == bit[-1]:\n+                        bit = unescape_string_literal(bit)\n+                    or_queries = models.Q(\n+                        *((orm_lookup, bit) for orm_lookup in orm_lookups),\n+                        _connector=models.Q.OR,\n+                    )\n+                    search_queries.append(or_queries)\n+                if search_queries:\n+                    queryset = queryset.filter(*search_queries)\n+            may_have_duplicates |= spawns_dupes\n         return queryset, may_have_duplicates\n \n     def get_preserved_filters(self, request):\n",
  "epics_created": 1,
  "epics_completed": 1,
  "start_time": "2026-02-03T03:10:59.846690",
  "end_time": "2026-02-03T03:25:13.105912",
  "duration_seconds": 853.259222,
  "error_message": null,
  "workspace_path": "<redacted>",
  "epic_comments": [
    {
      "epic_id": "32f5335e-8988-48fd-82ab-fc8a0a7e3d5a",
      "epic_title": "Fix: django__django-15022",
      "comment_id": "67beebee-e3af-426d-b019-456aec843e0f",
      "author_name": "Brainstormer",
      "content": "## Fix Summary\n\nFixed unnecessary joins in admin changelist query when searching with multiple words. The issue was that each search term triggered a separate `queryset.filter()` call, which could lead to performance issues with ForeignKey relationships.\n\n**Root Cause:** In `get_search_results()`, the pattern `qs = qs.filter(...)` for each search term was inefficient for ForeignKey-only searches, though it was necessary for many-to-many relationships to preserve correct semantics.\n\n**Solution:** \n- Detect if any search field lookup spawns duplicates (i.e., involves many-to-many relationships)\n- For **m2m relationships**: Use separate `filter()` calls (original behavior) - each search term can match a different related row\n- For **ForeignKey-only relationships**: Combine all search terms into a single `filter()` call - avoids creating unnecessary JOINs\n\n## Files Modified\n- `django/contrib/admin/options.py` (lines 1029-1067): Added logic to detect relationship types and optimize filter calls accordingly\n\n## Test Results\n- **admin_changelist tests:** 71 passed, 6 skipped \u2713\n- **admin_views tests:** 426 passed, 28 skipped \u2713\n- **admin_filters + admin_ordering tests:** 56 passed \u2713\n\n## Key Changes\nThe fix distinguishes between:\n1. **Many-to-many lookups** (e.g., `members__name`): Keep separate filter() calls to preserve semantics where each search term can match a different related object\n2. **ForeignKey lookups** (e.g., `clientoffice__name`): Combine all search terms into one filter() call to avoid duplicate JOINs\n\nThis preserves the correct behavior for m2m relationships while optimizing performance for ForeignKey-only searches.",
      "created_at": "2026-02-03T02:23:48.068Z"
    },
    {
      "epic_id": "32f5335e-8988-48fd-82ab-fc8a0a7e3d5a",
      "epic_title": "Fix: django__django-15022",
      "comment_id": "b0cf93b4-cb19-4331-96af-af8758f98f4a",
      "author_name": "Code Reviewer",
      "content": "Code review PASSED.\n\n- Only source file changed: `django/contrib/admin/options.py`.\n- Change is minimal and directly targets the reported admin search behavior by avoiding repeated `filter()` calls (and thus unnecessary JOIN proliferation) when lookups don\u2019t spawn duplicates, while preserving the per-term filtering semantics for m2m lookups.\n- No obvious correctness or crash issues spotted in the updated `get_search_results()` logic.",
      "created_at": "2026-02-03T02:25:00.579Z"
    }
  ]
}