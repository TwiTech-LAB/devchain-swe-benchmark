{
  "instance_id": "mwaskom__seaborn-3187",
  "status": "completed",
  "patch": "diff --git a/seaborn/_core/scales.py b/seaborn/_core/scales.py\nindex 55874bf2..18a55faf 100644\n--- a/seaborn/_core/scales.py\n+++ b/seaborn/_core/scales.py\n@@ -379,6 +379,26 @@ class ContinuousBase(Scale):\n             locs = axis.major.locator()\n             locs = locs[(vmin <= locs) & (locs <= vmax)]\n             labels = axis.major.formatter.format_ticks(locs)\n+            # Account for formatter offset (e.g., 1e6) in legend labels\n+            offset = axis.major.formatter.get_offset()\n+            if offset:\n+                # Parse the offset string and combine with labels\n+                # Offset can be '1e6', '\u00d710\u2076', or similar formats\n+                offset_lower = offset.lower()\n+                if 'e' in offset_lower and '\u00d7' not in offset:\n+                    # Format like '1e6' -> append 'e6' to each label\n+                    parts = offset_lower.split('e')\n+                    if len(parts) == 2:\n+                        exponent = parts[1]\n+                        labels = [f\"{label}e{exponent}\" for label in labels]\n+                elif '\u00d710' in offset or 'x10' in offset_lower:\n+                    # Unicode format like '\u00d710\u2076' -> convert to 'e6' format\n+                    import re\n+                    match = re.search(r'[\u00d7x]10(.+)', offset)\n+                    if match:\n+                        superscript_map = str.maketrans('\u2070\u00b9\u00b2\u00b3\u2074\u2075\u2076\u2077\u2078\u2079', '0123456789')\n+                        exponent = match.group(1).translate(superscript_map)\n+                        labels = [f\"{label}e{exponent}\" for label in labels]\n             new._legend = list(locs), list(labels)\n \n         return new\ndiff --git a/seaborn/utils.py b/seaborn/utils.py\nindex 2407853c..f7608715 100644\n--- a/seaborn/utils.py\n+++ b/seaborn/utils.py\n@@ -707,6 +707,27 @@ def locator_to_legend_entries(locator, limits, dtype):\n     formatter.set_locs(raw_levels)\n     formatted_levels = [formatter(x) for x in raw_levels]\n \n+    # Account for formatter offset (e.g., 1e6) in formatted levels\n+    offset = formatter.get_offset()\n+    if offset:\n+        # Parse the offset string and combine with labels\n+        # Offset can be '1e6', '\u00d710\u2076', or similar formats\n+        offset_lower = offset.lower()\n+        if 'e' in offset_lower and '\u00d7' not in offset:\n+            # Format like '1e6' -> append 'e6' to each label\n+            parts = offset_lower.split('e')\n+            if len(parts) == 2:\n+                exponent = parts[1]\n+                formatted_levels = [f\"{label}e{exponent}\" for label in formatted_levels]\n+        elif '\u00d710' in offset or 'x10' in offset_lower:\n+            # Unicode format like '\u00d710\u2076' -> convert to 'e6' format\n+            import re\n+            match = re.search(r'[\u00d7x]10(.+)', offset)\n+            if match:\n+                superscript_map = str.maketrans('\u2070\u00b9\u00b2\u00b3\u2074\u2075\u2076\u2077\u2078\u2079', '0123456789')\n+                exponent = match.group(1).translate(superscript_map)\n+                formatted_levels = [f\"{label}e{exponent}\" for label in formatted_levels]\n+\n     return raw_levels, formatted_levels\n \n \n",
  "epics_created": 1,
  "epics_completed": 1,
  "start_time": "2026-02-03T06:23:32.187338",
  "end_time": "2026-02-03T06:38:52.751821",
  "duration_seconds": 920.564483,
  "error_message": null,
  "workspace_path": "<redacted>",
  "epic_comments": [
    {
      "epic_id": "5c0d53e4-e052-4880-9a15-222ec65f636d",
      "epic_title": "Fix: mwaskom__seaborn-3187",
      "comment_id": "f543ab35-2da8-40f3-9c85-268a923eac26",
      "author_name": "Brainstormer",
      "content": "## Fix Summary\n\nFixed the issue where legends describing large numbers (using `ScalarFormatter` with an offset) were formatted without their multiplicative offset value. For example, values in the order of 1E6 were shown as `3.0, 3.6, 4.2...` instead of `3.0e6, 3.6e6, 4.2e6...`\n\n## Files Modified\n\n- **seaborn/_core/scales.py**: Added offset handling for the new seaborn.objects interface (ContinuousBase._setup method around line 379)\n- **seaborn/utils.py**: Added offset handling in locator_to_legend_entries function for traditional scatterplot/relational plots\n\n## Root Cause\n\nThe `ScalarFormatter` in matplotlib uses an offset (e.g., `1e6`) to compactly display large tick values. This offset is shown separately on the axis (e.g., at the top) but wasn't being included in the legend labels. The formatter returns labels like `['3.0', '3.6']` with offset `'1e6'`, and the legend needs to combine these properly.\n\n## Solution\n\nAfter getting the formatted labels from the formatter:\n1. Check if the formatter has an offset via `get_offset()`\n2. Parse the offset string (supports formats like `'1e6'` and `'\u00d710\u2076'`)\n3. Combine each label with the exponent to show the full value (e.g., `'3.0' + '1e6' \u2192 '3.0e6'`)\n\n## Test Results\n\n- **Baseline (before fix):** 83 passed, 1 xfailed, 2 warnings\n- **After fix:** 83 passed, 1 xfailed, 2 warnings (no regressions)\n- **Related tests:** All legend tests pass (13 in test_plot.py, 3 in test_relational.py)\n- **All _core tests:** 509 passed, 6 xfailed\n\n## Verification\n\nBoth interfaces now correctly show the full values:\n- scatterplot: `'3.0e6', '3.6e6', '4.2e6', '4.8e6', '5.4e6', '6.0e6'`\n- seaborn.objects: `'3e6', '4e6', '5e6', '6e6'`",
      "created_at": "2026-02-03T05:36:44.785Z"
    },
    {
      "epic_id": "5c0d53e4-e052-4880-9a15-222ec65f636d",
      "epic_title": "Fix: mwaskom__seaborn-3187",
      "comment_id": "875a5933-690a-4f74-8d46-840b4fc17ce5",
      "author_name": "Code Reviewer",
      "content": "Code review PASSED.\n\n- Changes are limited to source files (`seaborn/_core/scales.py`, `seaborn/utils.py`); no tests/config modified.\n- Fix directly targets the reported issue by incorporating `ScalarFormatter.get_offset()` into legend labels so values like `3.0` become `3.0e6` when an offset/scientific factor is active.\n\nNon-blocking note: the offset parsing is tailored to `1e6` / `\u00d710\u2076`-style strings; if matplotlib returns other mathtext forms (e.g., `10^{6}`), this may not be covered, but the approach is correct for the reported regression.",
      "created_at": "2026-02-03T05:38:41.558Z"
    }
  ]
}