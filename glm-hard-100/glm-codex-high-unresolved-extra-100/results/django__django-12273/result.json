{
  "instance_id": "django__django-12273",
  "status": "completed",
  "patch": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 844c01e95e..310f61a785 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -569,7 +569,17 @@ class Model(metaclass=ModelBase):\n         return getattr(self, meta.pk.attname)\n \n     def _set_pk_val(self, value):\n-        return setattr(self, self._meta.pk.attname, value)\n+        setattr(self, self._meta.pk.attname, value)\n+        # If the primary key is a link to a parent model (multi-table\n+        # inheritance), also update the value of the parent's primary key.\n+        # This is the reverse of the sync that happens in\n+        # ForwardOneToOneDescriptor.__set__ when setting the parent link.\n+        opts = self._meta\n+        for parent in opts.parents:\n+            link_field = opts.parents[parent]\n+            if link_field and link_field == opts.pk and link_field.remote_field.parent_link:\n+                # The primary key is a parent link, so sync the parent's PK.\n+                setattr(self, parent._meta.pk.attname, value)\n \n     pk = property(_get_pk_val, _set_pk_val)\n \ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 96409cc67c..3bc752685b 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -151,6 +151,26 @@ class DeferredAttribute:\n             data[field_name] = val\n         return data[field_name]\n \n+    def __set__(self, instance, value):\n+        \"\"\"\n+        Set the value on the instance. If the field is a primary key from an\n+        ancestor model and the instance's class uses multi-table inheritance,\n+        also update the instance's primary key field.\n+        \"\"\"\n+        instance.__dict__[self.field.attname] = value\n+        # If this field is a primary key from an ancestor model, also set the\n+        # value on the descendant model's primary key field. This is required\n+        # for multi-table inheritance where the descendant's primary key is a\n+        # OneToOneField pointing to the ancestor.\n+        if self.field.primary_key:\n+            opts = instance._meta\n+            link_field = opts.get_ancestor_link(self.field.model)\n+            # link_field is the OneToOneField on the descendant that points to\n+            # this ancestor. If this field's model is different from the\n+            # instance's model, we're in a multi-table inheritance scenario.\n+            if link_field and self.field != link_field:\n+                setattr(instance, link_field.attname, value)\n+\n     def _check_parent_chain(self, instance):\n         \"\"\"\n         Check if the field value can be fetched from a parent field already\n",
  "epics_created": 1,
  "epics_completed": 1,
  "start_time": "2026-02-03T02:12:14.704055",
  "end_time": "2026-02-03T02:30:46.883601",
  "duration_seconds": 1112.179546,
  "error_message": null,
  "workspace_path": "<redacted>",
  "epic_comments": [
    {
      "epic_id": "9ed2ed0e-d2d9-4440-b810-63732061ba76",
      "epic_title": "Fix: django__django-12273",
      "comment_id": "8102bf4a-413f-4ec1-91a8-52d9204b95cb",
      "author_name": "Brainstormer",
      "content": "## Fix Summary\n\nFixed the bug where resetting the primary key for a child model in multi-table inheritance doesn't work. When `self.uid = None` was called on a derived model instance, only the parent's PK field was set to None, but the derived model's PK field (the OneToOneField parent link) still had the old value. This caused save() to overwrite the existing object instead of creating a new one.\n\nThe fix adds bidirectional synchronization of PK values between parent and child models in multi-table inheritance:\n\n1. **In `DeferredAttribute.__set__`** (django/db/models/query_utils.py): When setting an inherited PK field (e.g., `uid` from parent), also update the descendant's PK field (the OneToOneField link).\n\n2. **In `Model._set_pk_val`** (django/db/models/base.py): When setting the PK on a derived model (e.g., `obj.pk = None`), also update the parent's PK field.\n\n## Files Modified\n- `django/db/models/query_utils.py`: Added `__set__` method to `DeferredAttribute` class\n- `django/db/models/base.py`: Modified `_set_pk_val` method to sync parent PK in multi-table inheritance\n\n## Test Results\nVerified the fix works for all scenarios:\n1. Original bug scenario: `obj.reset()` which sets `self.uid = None` - now correctly creates a new object\n2. Setting `obj.pk = None` - correctly syncs to parent PK\n3. Setting `obj.uid = None` - correctly syncs to child PK\n4. Setting specific PK values - bidirectional sync works correctly\n\n## Edge Cases Considered\n- Empty inputs (None values)\n- Both directions of PK assignment (parent\u2192child and child\u2192parent)\n- Multi-level inheritance (handled by the parent chain lookup)\n- Non-primary-key fields (not affected by this fix)",
      "created_at": "2026-02-03T01:26:18.656Z"
    },
    {
      "epic_id": "9ed2ed0e-d2d9-4440-b810-63732061ba76",
      "epic_title": "Fix: django__django-12273",
      "comment_id": "21201e60-7725-42d3-b7f3-f3cd2b4a54d0",
      "author_name": "Code Reviewer",
      "content": "Code review PASSED.\n\n- Changes are limited to `django/db/models/base.py` and `django/db/models/query_utils.py` (no tests/build config touched).\n- The fix directly addresses the reported MTI bug by synchronizing PK assignments between an ancestor PK field (e.g., `uid`) and the child model\u2019s parent-link PK (OneToOneField attname), preventing `save()` from updating the original row when `self.uid = None`.\n\nNote: I didn\u2019t see container test output in the summary (only scenario verification). That\u2019s OK for this review, but running the relevant model tests in the container would further de-risk regressions.",
      "created_at": "2026-02-03T01:30:35.560Z"
    }
  ]
}