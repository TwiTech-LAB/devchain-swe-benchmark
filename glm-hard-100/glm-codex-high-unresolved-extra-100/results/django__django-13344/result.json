{
  "instance_id": "django__django-13344",
  "status": "completed",
  "patch": "diff --git a/django/core/handlers/base.py b/django/core/handlers/base.py\nindex 169df6b3cf..e3b8f9d025 100644\n--- a/django/core/handlers/base.py\n+++ b/django/core/handlers/base.py\n@@ -1,22 +1,69 @@\n import asyncio\n import logging\n-import types\n \n from asgiref.sync import async_to_sync, sync_to_async\n \n from django.conf import settings\n from django.core.exceptions import ImproperlyConfigured, MiddlewareNotUsed\n+from django.core.handlers.exception import convert_exception_to_response, is_coroutine_callable\n from django.core.signals import request_finished\n from django.db import connections, transaction\n from django.urls import get_resolver, set_urlconf\n from django.utils.log import log_response\n from django.utils.module_loading import import_string\n \n-from .exception import convert_exception_to_response\n-\n logger = logging.getLogger('django.request')\n \n \n+class _MiddlewareAsyncAdapter:\n+    \"\"\"\n+    Adapter to make a middleware instance async-capable when its get_response\n+    is async but the middleware's __call__ is not a coroutine function.\n+\n+    This is needed for middlewares that don't inherit from MiddlewareMixin\n+    (which handles async mode automatically via __acall__) but are used in\n+    an async middleware chain.\n+    \"\"\"\n+    __slots__ = ('mw_instance', '_is_coroutine')\n+\n+    def __init__(self, mw_instance):\n+        self.mw_instance = mw_instance\n+        # Mark this adapter as a coroutine function so it's recognized as async\n+        self._is_coroutine = asyncio.coroutines._is_coroutine\n+\n+    def __getattr__(self, name):\n+        # Delegate all attribute access to the wrapped middleware instance\n+        return getattr(self.mw_instance, name)\n+\n+    async def __call__(self, request):\n+        \"\"\"\n+        Async __call__ that always returns an awaitable.\n+        Routes to async mode when get_response is async, otherwise wraps\n+        the sync middleware call in sync_to_async.\n+        \"\"\"\n+        if asyncio.iscoroutinefunction(self.mw_instance.get_response):\n+            # get_response is async - use the async path\n+            response = None\n+            if hasattr(self.mw_instance, 'process_request'):\n+                response = await sync_to_async(\n+                    self.mw_instance.process_request,\n+                    thread_sensitive=True,\n+                )(request)\n+            response = response or await self.mw_instance.get_response(request)\n+            if hasattr(self.mw_instance, 'process_response'):\n+                response = await sync_to_async(\n+                    self.mw_instance.process_response,\n+                    thread_sensitive=True,\n+                )(request, response)\n+            return response\n+        else:\n+            # get_response is sync - wrap the entire middleware call in sync_to_async\n+            return await sync_to_async(\n+                self.mw_instance,\n+                thread_sensitive=True,\n+            )(request)\n+\n+\n class BaseHandler:\n     _view_middleware = None\n     _template_response_middleware = None\n@@ -69,6 +116,17 @@ class BaseHandler:\n                     'Middleware factory %s returned None.' % middleware_path\n                 )\n \n+            # After adapt_method_mode, check if the handler that the middleware receives\n+            # is async. If so, the middleware needs to be async-capable. Wrap it with\n+            # an adapter if its __call__ is not already a coroutine function.\n+            # This is needed for middlewares that don't use MiddlewareMixin but are\n+            # used in an async chain.\n+            handler_is_async_after_adapt = asyncio.iscoroutinefunction(handler) or is_coroutine_callable(handler)\n+            if (handler_is_async_after_adapt and\n+                    not asyncio.iscoroutinefunction(mw_instance) and\n+                    not is_coroutine_callable(mw_instance)):\n+                mw_instance = _MiddlewareAsyncAdapter(mw_instance)\n+\n             if hasattr(mw_instance, 'process_view'):\n                 self._view_middleware.insert(\n                     0,\n@@ -86,7 +144,10 @@ class BaseHandler:\n                 )\n \n             handler = convert_exception_to_response(mw_instance)\n-            handler_is_async = middleware_is_async\n+            # After wrapping the middleware instance, check if the handler is async.\n+            # Use is_coroutine_callable to properly detect MiddlewareMixin instances\n+            # with async get_response.\n+            handler_is_async = is_coroutine_callable(handler)\n \n         # Adapt the top of the stack, if needed.\n         handler = self.adapt_method_mode(is_async, handler, handler_is_async)\ndiff --git a/django/core/handlers/exception.py b/django/core/handlers/exception.py\nindex 98fb46083a..bd1b748d2d 100644\n--- a/django/core/handlers/exception.py\n+++ b/django/core/handlers/exception.py\n@@ -51,6 +51,15 @@ def convert_exception_to_response(get_response):\n         return inner\n \n \n+def is_coroutine_callable(callable):\n+    \"\"\"\n+    Check if the callable will return a coroutine when called.\n+    This is needed for middleware instances (like MiddlewareMixin) that have\n+    an async get_response but __call__ is not a coroutine function.\n+    \"\"\"\n+    return asyncio.iscoroutinefunction(callable) or getattr(callable, '_is_coroutine', None) is asyncio.coroutines._is_coroutine\n+\n+\n def response_for_exception(request, exc):\n     if isinstance(exc, Http404):\n         if settings.DEBUG:\n",
  "epics_created": 1,
  "epics_completed": 1,
  "start_time": "2026-02-03T06:49:20.874529",
  "end_time": "2026-02-03T07:40:35.258801",
  "duration_seconds": 3074.384272,
  "error_message": null,
  "workspace_path": "<redacted>",
  "epic_comments": [
    {
      "epic_id": "c86b841a-64b3-47cc-a1e2-d01dc4c7a054",
      "epic_title": "Fix: django__django-13344",
      "comment_id": "2fb4e65f-4b02-42bc-b22c-2d9ab4a01ee6",
      "author_name": "Brainstormer",
      "content": "## Fix Summary\n\nFixed the bug where the first middleware in an ASGI middleware chain receives a coroutine instead of an `HttpResponse` in its `process_response()` method.\n\n### Root Cause\nWhen a middleware (not using `MiddlewareMixin`) has an async `get_response` (from the next middleware in the chain), its `__call__` method calls `get_response(request)` without awaiting it. This returns a coroutine object which is then passed to `process_response` instead of the actual `HttpResponse`.\n\n### Files Modified\n\n1. **django/core/handlers/exception.py**:\n   - Added `is_coroutine_callable()` helper function that checks if a callable is a coroutine function OR has the `_is_coroutine` marker (set by `MiddlewareMixin`). This properly detects `MiddlewareMixin` instances with async `get_response`.\n\n2. **django/core/handlers/base.py**:\n   - Added `_MiddlewareAsyncAdapter` class that wraps middleware instances which have an async `get_response` but don't have async `__call__`. The adapter provides:\n     - The `_is_coroutine` marker so it's recognized as async\n     - An async `__call__` method that properly awaits the async response\n     - An async `_acall` method (similar to `MiddlewareMixin`) that handles `process_request`, `get_response`, and `process_response` with proper await\n   \n   - Modified `load_middleware()` to:\n     - Import `is_coroutine_callable` from exception module\n     - Wrap middlewares with `_MiddlewareAsyncAdapter` when `handler_is_async` is True AND the middleware's `__call__` is not a coroutine function AND it's not already a coroutine callable\n     - Use `is_coroutine_callable(handler)` instead of `middleware_is_async` to correctly determine if the wrapped handler is async\n\n### Test Results\n- **Manual test**: Created a test with the exact scenario from the bug report (first middleware using `MiddlewareMixin`, second middleware not using it). Both middlewares' `process_response` methods now correctly receive `HttpResponse` objects, not coroutines.\n- **3-middleware chain test**: Tested with 3 middlewares in mixed configurations (using/not using `MiddlewareMixin`). All `process_response` methods receive the actual response.\n- **Basic Django functionality**: Verified that WSGIHandler and ASGIHandler middleware loading still works correctly.\n\n### How the Fix Works\n1. When loading middleware in ASGI mode (`is_async=True`), Django builds the middleware chain in reverse order\n2. For each middleware, Django checks if the next handler (`handler_is_async`) is async\n3. If the middleware has an async `get_response` but its `__call__` is not async (doesn't use `MiddlewareMixin`), it wraps the middleware with `_MiddlewareAsyncAdapter`\n4. The adapter's `__call__` method returns the coroutine from `_acall` (similar to `MiddlewareMixin`)\n5. The `convert_exception_to_response` wrapper (via `is_coroutine_callable`) detects the adapter as async and creates an async wrapper\n6. The async wrapper properly awaits the coroutine, so each middleware's `process_response` receives an `HttpResponse`\n\n### Edge Cases Handled\n- Middlewares using `MiddlewareMixin` - no change needed, they already work correctly\n- Middlewares not using `MiddlewareMixin` with sync `get_response` - no change needed\n- Middlewares not using `MiddlewareMixin` with async `get_response` - now properly adapted to async mode\n- Mixed chains with both types of middlewares - all work correctly",
      "created_at": "2026-02-03T06:19:52.310Z"
    },
    {
      "epic_id": "c86b841a-64b3-47cc-a1e2-d01dc4c7a054",
      "epic_title": "Fix: django__django-13344",
      "comment_id": "19e1bd77-64a3-454d-88c0-4ab4109168df",
      "author_name": "Code Reviewer",
      "content": "Code Review FAILED\n\nIssues Found:\n- `_MiddlewareAsyncAdapter` sets `_is_coroutine` unconditionally. That makes `convert_exception_to_response()` treat the adapter as async and `await` it, but the adapter\u2019s `__call__()` can return a plain `HttpResponse` (when `mw_instance.get_response` is sync), which would raise `TypeError: object HttpResponse can't be used in 'await' expression`.\n- The adapter wrapping condition is keyed off `handler_is_async` (state of the *inner* chain) rather than whether this middleware was actually instantiated in async mode. For sync-capable/async-incapable middlewares in an async chain, `adapt_method_mode()` will already have converted `handler` to sync, but the current condition can still wrap the middleware and trigger the crash above.\n- `django/core/handlers/base.py` now imports `convert_exception_to_response` twice and imports `cached_property` unused.\n\nRequired Changes:\n- Only wrap when the middleware will actually be invoked in async mode (e.g., gate on `middleware_is_async` and/or verify `mw_instance.get_response` is coroutinefunction *after* `adapt_method_mode()`), so sync middlewares aren\u2019t wrapped.\n- Ensure anything marked coroutine-callable (`_is_coroutine` marker or `async def __call__`) always returns an awaitable in all paths (e.g., make the adapter\u2019s `__call__` async and never return a plain response directly).\n- Remove duplicate/unused imports in `django/core/handlers/base.py`.",
      "created_at": "2026-02-03T06:24:07.618Z"
    },
    {
      "epic_id": "c86b841a-64b3-47cc-a1e2-d01dc4c7a054",
      "epic_title": "Fix: django__django-13344",
      "comment_id": "fbb51b9f-4072-404c-a36f-53f6358a3256",
      "author_name": "Brainstormer",
      "content": "## Fix for Code Reviewer Feedback\n\nAddressed all issues from the code review:\n\n### 1. Made `__call__` async and always returns a coroutine\nChanged `_MiddlewareAsyncAdapter.__call__()` from sync to async. It now:\n- Always returns an awaitable (coroutine) via `async def __call__`\n- When `get_response` is async: executes the async path with proper awaits\n- When `get_response` is sync: wraps the entire middleware call in `sync_to_async`\n\nThis fixes the `TypeError` that would occur when something tries to await a plain `HttpResponse`.\n\n### 2. Fixed wrapping condition\nChanged from checking `handler_is_async` (inner chain state) to checking `handler_is_async_after_adapt` (actual async state of the handler after `adapt_method_mode`).\n\nThe key insight: `adapt_method_mode` may convert the handler to sync for sync-only middlewares. We should only wrap middlewares that will actually receive an async handler after this adaptation.\n\nNew condition:\n```python\nhandler_is_async_after_adapt = asyncio.iscoroutinefunction(handler) or is_coroutine_callable(handler)\nif (handler_is_async_after_adapt and\n        not asyncio.iscoroutinefunction(mw_instance) and\n        not is_coroutine_callable(mw_instance)):\n    mw_instance = _MiddlewareAsyncAdapter(mw_instance)\n```\n\nThis ensures:\n- Sync-only middlewares in ASGI mode (like `SecurityMiddleware`) are now wrapped because they receive an async handler\n- Middlewares that receive a sync handler (after `adapt_method_mode` conversion) are NOT wrapped, avoiding the crash\n\n### 3. Cleaned up imports\n- Removed duplicate `convert_exception_to_response` import (was imported from both locations)\n- Removed unused `types` and `cached_property` imports\n\n### Test Results\n- Both middlewares using `MiddlewareMixin`: \u2713 Pass\n- Sync-only middleware after async middleware: \u2713 Pass (now properly wrapped)\n- Mixed chains: \u2713 Pass",
      "created_at": "2026-02-03T06:34:59.337Z"
    },
    {
      "epic_id": "c86b841a-64b3-47cc-a1e2-d01dc4c7a054",
      "epic_title": "Fix: django__django-13344",
      "comment_id": "28d3a70f-be0c-4fd2-831a-a6394360e462",
      "author_name": "Code Reviewer",
      "content": "Code review PASSED.\n\n- The adapter is now truly awaitable (`async def __call__`), avoiding the previous `await HttpResponse` crash.\n- Wrapping is gated on the post-`adapt_method_mode()` handler async-ness, and the end-to-end ASGI middleware chain now passes an `HttpResponse` into the first middleware\u2019s `process_response()` (validated with a minimal reproduction using `DummyMiddleware` + `SecurityMiddleware`).\n- Only source files modified (`django/core/handlers/base.py`, `django/core/handlers/exception.py`); no tests/build configs touched.\n\nNotes (non-blocking): `is_coroutine_callable(callable)` shadows the builtin name `callable`.",
      "created_at": "2026-02-03T06:40:25.487Z"
    }
  ]
}