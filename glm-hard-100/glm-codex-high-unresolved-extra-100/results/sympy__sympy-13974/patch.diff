diff --git a/sympy/core/power.py b/sympy/core/power.py
index 02ec6480cb..49e52594a9 100644
--- a/sympy/core/power.py
+++ b/sympy/core/power.py
@@ -1062,6 +1062,19 @@ def _eval_expand_multinomial(self, **hints):
         else:
             return result
 
+    def _eval_expand_tensorproduct(self, **hints):
+        """Handle expansion of tensor product powers.
+        For TensorProduct(A, B)**n where n is an integer, distribute
+        the power to get TensorProduct(A**n, B**n).
+        """
+        from sympy.physics.quantum import TensorProduct
+        base = self.base
+        exp = self.exp
+        # Only distribute for integer exponents
+        if isinstance(base, TensorProduct) and exp.is_integer:
+            return TensorProduct(*[arg**exp for arg in base.args])
+        return self
+
     def as_real_imag(self, deep=True, **hints):
         from sympy import atan2, cos, im, re, sin
         from sympy.polys.polytools import poly
diff --git a/sympy/physics/quantum/tensorproduct.py b/sympy/physics/quantum/tensorproduct.py
index 9dd10d219e..bb04ea07f6 100644
--- a/sympy/physics/quantum/tensorproduct.py
+++ b/sympy/physics/quantum/tensorproduct.py
@@ -382,7 +382,12 @@ def tensor_product_simp(e, **hints):
     if isinstance(e, Add):
         return Add(*[tensor_product_simp(arg) for arg in e.args])
     elif isinstance(e, Pow):
-        return tensor_product_simp(e.base) ** e.exp
+        base = tensor_product_simp(e.base)
+        exp = e.exp
+        # If base is a TensorProduct with integer exponent, distribute the power
+        if isinstance(base, TensorProduct) and exp.is_integer:
+            return TensorProduct(*[arg**exp for arg in base.args])
+        return base ** exp
     elif isinstance(e, Mul):
         return tensor_product_simp_Mul(e)
     elif isinstance(e, Commutator):
