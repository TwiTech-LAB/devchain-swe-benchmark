{
  "instance_id": "pylint-dev__pylint-4551",
  "status": "completed",
  "patch": "diff --git a/pylint/pyreverse/inspector.py b/pylint/pyreverse/inspector.py\nindex 8fa122022..7d9d28e28 100644\n--- a/pylint/pyreverse/inspector.py\n+++ b/pylint/pyreverse/inspector.py\n@@ -166,6 +166,10 @@ class Linker(IdGeneratorMixIn, utils.LocalsVisitor):\n             for assignattr in assignattrs:\n                 if not isinstance(assignattr, astroid.Unknown):\n                     self.handle_assignattr_type(assignattr, node)\n+        # handle type annotations (AnnAssign nodes)\n+        for child in node.body:\n+            if isinstance(child, astroid.AnnAssign):\n+                self.visit_annassign(child)\n         # resolve implemented interface\n         try:\n             node.implements = list(interfaces(node, self.inherited_interfaces))\n@@ -236,6 +240,82 @@ class Linker(IdGeneratorMixIn, utils.LocalsVisitor):\n         except astroid.InferenceError:\n             pass\n \n+        # Check if the assigned value has a type annotation in the function parameters\n+        # This handles cases like: self.a = a where 'a' has a type annotation\n+        try:\n+            # Get the parent Assign node which contains the assigned value\n+            assign_node = node.parent\n+            if isinstance(assign_node, astroid.Assign) and isinstance(assign_node.value, astroid.Name):\n+                assigned_name = assign_node.value.name\n+                # Check if this is inside a function\n+                frame = assign_node.frame()\n+                if isinstance(frame, astroid.FunctionDef):\n+                    args = frame.args\n+                    if args:\n+                        # Find the index of this parameter\n+                        for i, arg in enumerate(args.args):\n+                            if arg.name == assigned_name:\n+                                # Check if there's a type annotation for this parameter\n+                                if i < len(args.annotations) and args.annotations[i] is not None:\n+                                    annotation = args.annotations[i]\n+                                    # Infer the type from the annotation\n+                                    try:\n+                                        types = set()\n+                                        for inferred in annotation.infer():\n+                                            if inferred is not astroid.Uninferable:\n+                                                types.add(inferred)\n+                                        if types:\n+                                            current = set(parent.instance_attrs_type[node.attrname])\n+                                            parent.instance_attrs_type[node.attrname] = list(current | types)\n+                                    except astroid.InferenceError:\n+                                        pass\n+                                break\n+        except (AttributeError, IndexError, astroid.InferenceError):\n+            pass\n+\n+    def visit_annassign(self, node):\n+        \"\"\"visit an astroid.AnnAssign node and handle type annotations.\"\"\"\n+        # Get the frame (class) containing this annotation\n+        frame = node.frame()\n+        if not isinstance(frame, astroid.ClassDef):\n+            return\n+\n+        # Ensure the class has been visited and has instance_attrs_type\n+        if not hasattr(frame, \"instance_attrs_type\"):\n+            self.visit_classdef(frame)\n+\n+        # Extract the variable name from the annotation target\n+        target = node.target\n+        # Determine the type dictionary to use and the attribute name\n+        if isinstance(target, astroid.AssignName):\n+            # Class-level annotation like: a: str\n+            # Store in locals_type\n+            name = target.name\n+            type_dict = frame.locals_type\n+        elif isinstance(target, astroid.AssignAttr):\n+            # Instance attribute annotation like: self.a: str\n+            # Store in instance_attrs_type\n+            name = target.attrname\n+            type_dict = frame.instance_attrs_type\n+        else:\n+            return\n+\n+        # Extract the type from the annotation\n+        if node.annotation is not None:\n+            try:\n+                # Try to infer the type from the annotation\n+                types = set()\n+                for inferred in node.annotation.infer():\n+                    if inferred is not astroid.Uninferable:\n+                        types.add(inferred)\n+\n+                # If we have inferred types, add them to the appropriate dictionary\n+                if types:\n+                    current = set(type_dict[name])\n+                    type_dict[name] = list(current | types)\n+            except astroid.InferenceError:\n+                pass\n+\n     def visit_import(self, node):\n         \"\"\"visit an astroid.Import node\n \n",
  "epics_created": 1,
  "epics_completed": 1,
  "start_time": "2026-02-03T01:56:48.826382",
  "end_time": "2026-02-03T02:13:19.676336",
  "duration_seconds": 990.849954,
  "error_message": null,
  "workspace_path": "<redacted>",
  "epic_comments": [
    {
      "epic_id": "b5b2f82b-05ce-4190-a43f-52ae21ef8650",
      "epic_title": "Fix: pylint-dev__pylint-4551",
      "comment_id": "cd09e6ac-3663-4b49-ad10-476cf317c415",
      "author_name": "Brainstormer",
      "content": "## Fix Summary\n\nFixed pyreverse to read Python type hints (PEP 484) for UML generation. The fix adds support for:\n\n1. **Function parameter annotations** - When `self.a = a` is assigned, the type annotation of parameter `a` is now extracted and stored\n2. **Class-level annotations** - Class-level type annotations like `a: str` are now processed\n\n## Files Modified\n\n- `pylint/pyreverse/inspector.py`: \n  - Modified `handle_assignattr_type()` to extract type annotations from function parameters when assigning to instance attributes\n  - Added `visit_annassign()` method to process `AnnAssign` nodes for class-level type annotations\n  - Modified `visit_classdef()` to iterate over class body and process `AnnAssign` nodes\n\n## Test Results\n\n- **Test files:** `tests/unittest_pyreverse_inspector.py`, `tests/unittest_pyreverse_diadefs.py`, `tests/unittest_pyreverse_writer.py`\n- **Baseline:** All tests passing\n- **After fix:** All 23 tests passing, no regressions\n\n## Verification\n\nTested with pyreverse on sample code:\n\n```python\nclass C(object):\n    def __init__(self, a: str = None):\n        self.a = a\n\nclass D(object):\n    x: int\n    y: str = 'hello'\n    def __init__(self, foo: str):\n        self.foo = foo\n```\n\nOutput UML diagram now shows:\n- `C` class: `a : NoneType, str` \u2705\n- `D` class: `foo : str`, `x : int`, `y : str` \u2705\n\n## Edge Cases Considered\n\n- Empty/None annotations handled gracefully\n- Invalid annotations caught with try/except blocks\n- Both `AssignName` (class-level) and `AssignAttr` (instance attribute) annotations handled\n- Function parameter annotations properly extracted from `args.annotations` list",
      "created_at": "2026-02-03T01:10:38.618Z"
    },
    {
      "epic_id": "b5b2f82b-05ce-4190-a43f-52ae21ef8650",
      "epic_title": "Fix: pylint-dev__pylint-4551",
      "comment_id": "cfaa8670-8b05-4426-bf4a-628133b4a785",
      "author_name": "Code Reviewer",
      "content": "Code review PASSED.\n\n- Changes are limited to `pylint/pyreverse/inspector.py` (no tests or unrelated files modified).\n- Fix directly targets the reported issue by augmenting `instance_attrs_type` from function-parameter annotations when assigning `self.<attr> = <param>`.\n- Adds reasonable support for class-level `AnnAssign` annotations to populate `locals_type` / `instance_attrs_type`.\n\nNote (non-blocking): the parameter-annotation logic unions inferred value types with annotation types, so attributes may show `NoneType, str` for `a: str = None`, which still surfaces the desired `str` in UML output.",
      "created_at": "2026-02-03T01:13:15.425Z"
    }
  ]
}