{
  "instance_id": "sympy__sympy-19495",
  "status": "completed",
  "patch": "diff --git a/sympy/sets/conditionset.py b/sympy/sets/conditionset.py\nindex 118eda6f77..c8c70929d9 100644\n--- a/sympy/sets/conditionset.py\n+++ b/sympy/sets/conditionset.py\n@@ -243,7 +243,7 @@ def _eval_subs(self, old, new):\n         cond = self.condition.subs(old, new)\n         base = self.base_set.subs(old, new)\n         if cond is S.true:\n-            return ConditionSet(new, Contains(new, base), base)\n+            return base\n         return self.func(self.sym, cond, base)\n \n     def dummy_eq(self, other, symbol=None):\n",
  "epics_created": 1,
  "epics_completed": 1,
  "start_time": "2026-02-03T03:01:28.517179",
  "end_time": "2026-02-03T03:10:49.434755",
  "duration_seconds": 560.917576,
  "error_message": null,
  "workspace_path": "<redacted>",
  "epic_comments": [
    {
      "epic_id": "8399bd15-8612-4383-94b1-2d6883b36d3c",
      "epic_title": "Fix: sympy__sympy-19495",
      "comment_id": "fe33acc8-1b2c-4c79-8cd2-b19c48926446",
      "author_name": "Brainstormer",
      "content": "## Fix Summary\n\nFixed the strange behavior of `subs()` with ConditionSet/ImageSet. When the condition evaluates to `S.true` after substitution, the code was creating an invalid ConditionSet with the substituted value (e.g., `Rational(1,3)`) as the dummy variable, which is nonsensical.\n\nThe fix is simple: when `cond is S.true`, just return `base` directly instead of creating a new ConditionSet with `new` as the dummy variable.\n\n## Files Modified\n- `sympy/sets/conditionset.py`: Line 246 - Changed `return ConditionSet(new, Contains(new, base), base)` to `return base`\n\n## Root Cause\n\nIn `_eval_subs` method:\n```python\n# Old code (buggy):\nif cond is S.true:\n    return ConditionSet(new, Contains(new, base), base)\n\n# New code (fixed):\nif cond is S.true:\n    return base\n```\n\nWhen substituting `y = Rational(1,3)` in `ConditionSet(x, Contains(y, Interval(-1,1)), ImageSet(...))`:\n- The condition `Contains(Rational(1,3), Interval(-1,1))` becomes `S.true`\n- The buggy code returned `ConditionSet(Rational(1/3), Contains(Rational(1/3), base), base)` which is invalid\n- The fix returns just the `base` ImageSet with the substitution applied\n\n## Test Results\n\nVerified the fix works correctly:\n- `ConditionSet(x, Contains(y, Interval(-1,1)), imageset(Lambda(n, 2*n*pi + asin(y)), S.Integers)).subs(y, 1/3)` \n  - Before: `ConditionSet(1/3, Contains(1/3, ImageSet(...)), ImageSet(...))` (invalid)\n  - After: `ImageSet(Lambda(n, 2*pi*n + asin(1/3)), Integers)` (correct)\n- Result now matches `xreplace` and `simultaneous=True` behavior\n- Edge cases verified:\n  - Condition becomes `S.false` \u2192 Returns `EmptySet` (correct)\n  - Condition remains symbolic \u2192 Returns `ConditionSet` with updated condition (correct)\n\n## Notes\n- Tests 6 and 7 from `test_subs_CondSet` were already failing in the original code (pre-existing issues unrelated to this fix)",
      "created_at": "2026-02-03T02:09:21.457Z"
    },
    {
      "epic_id": "8399bd15-8612-4383-94b1-2d6883b36d3c",
      "epic_title": "Fix: sympy__sympy-19495",
      "comment_id": "612716de-c5cc-4da4-9f82-a27e586bef01",
      "author_name": "Code Reviewer",
      "content": "Code review PASSED.\n\n- `git diff` shows a single, minimal source change in `sympy/sets/conditionset.py` and no test/config modifications.\n- Returning `base` when `cond is S.true` avoids constructing an invalid `ConditionSet(new, ...)` (e.g. `new = Rational(1, 3)`) and matches the intended set semantics (`ConditionSet(..., True, base) == base`).\n\nLooks aligned with the reported `ConditionSet`/`ImageSet` `subs()` bug.",
      "created_at": "2026-02-03T02:10:40.133Z"
    }
  ]
}