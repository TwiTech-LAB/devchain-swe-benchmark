{
  "instance_id": "django__django-16263",
  "status": "completed",
  "patch": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 9735ce10c8..dd3a32e611 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -545,11 +545,79 @@ class Query(BaseExpression):\n \n         return dict(zip(outer_query.annotation_select, result))\n \n+    def _get_annotation_refs(self, expr, check_identity=True):\n+        \"\"\"\n+        Return a set of annotation names referenced by the given expression.\n+        If check_identity is True, also check if expr is the same object as\n+        an annotation (by object identity).\n+        \"\"\"\n+        refs = set()\n+        if isinstance(expr, Ref):\n+            refs.add(expr.refs)\n+        # Check if this expression is exactly the same object as an annotation\n+        if check_identity:\n+            for name, annotation in self.annotations.items():\n+                if expr is annotation:\n+                    refs.add(name)\n+        if hasattr(expr, \"get_source_expressions\"):\n+            for source in expr.get_source_expressions():\n+                refs.update(self._get_annotation_refs(source, check_identity))\n+        return refs\n+\n+    def _get_used_annotation_names(self):\n+        \"\"\"\n+        Return the set of annotation names that are used by the query.\n+        An annotation is used if it's referenced by:\n+        - A filter (where clause)\n+        - An ordering\n+        - Another annotation (transitively)\n+        \"\"\"\n+        used_names = set()\n+\n+        # Check where clause for annotation references\n+        if self.where:\n+            for child in self.where.children:\n+                used_names.update(self._get_annotation_refs(child))\n+\n+        # Check order_by for annotation references\n+        for item in self.order_by:\n+            if isinstance(item, str):\n+                if item.startswith(\"-\"):\n+                    item = item[1:]\n+                if item in self.annotations:\n+                    used_names.add(item)\n+            elif hasattr(item, \"get_source_expressions\"):\n+                for source in item.get_source_expressions():\n+                    used_names.update(self._get_annotation_refs(source))\n+\n+        # Transitively check if referenced annotations reference others\n+        to_process = list(used_names)\n+        while to_process:\n+            name = to_process.pop()\n+            if name in self.annotations:\n+                for ref in self._get_annotation_refs(self.annotations[name]):\n+                    if ref not in used_names:\n+                        used_names.add(ref)\n+                        to_process.append(ref)\n+\n+        return used_names\n+\n     def get_count(self, using):\n         \"\"\"\n         Perform a COUNT() query using the current filter constraints.\n         \"\"\"\n         obj = self.clone()\n+        # Find which annotations are used by filters, ordering, or other annotations.\n+        used_names = obj._get_used_annotation_names()\n+        unused_names = set(obj.annotations.keys()) - used_names\n+\n+        # Set the annotation_select_mask to exclude unused annotations.\n+        # This keeps the annotations in the dict (so get_aggregation uses the\n+        # subquery path when needed) but excludes them from the SELECT clause.\n+        if unused_names:\n+            # The mask should include only used annotations (and later __count)\n+            obj.set_annotation_mask(used_names)\n+\n         obj.add_annotation(Count(\"*\"), alias=\"__count\", is_summary=True)\n         return obj.get_aggregation(using, [\"__count\"])[\"__count\"]\n \n",
  "epics_created": 1,
  "epics_completed": 1,
  "start_time": "2026-02-03T11:27:27.518296",
  "end_time": "2026-02-03T11:52:10.104898",
  "duration_seconds": 1482.586602,
  "error_message": null,
  "workspace_path": "<redacted>",
  "epic_comments": [
    {
      "epic_id": "448ccd12-cffe-46ca-bb7f-fb3219d0f983",
      "epic_title": "Fix: django__django-16263",
      "comment_id": "9f4dbd55-82f4-4a18-9712-82e5b1f71ce0",
      "author_name": "Brainstormer",
      "content": "## Fix Summary\n\nFixed the issue where unused annotations were included in count queries, causing unnecessary joins and slower queries. The fix now strips unused annotations from the SELECT clause while preserving the subquery logic that handles joins correctly.\n\n## Files Modified\n- `django/db/models/sql/query.py`:\n  - Added `_get_annotation_refs(expr, check_identity=True)` helper method to find annotation references in expressions\n  - Added `_get_used_annotation_names()` method to determine which annotations are used by filters, ordering, or other annotations\n  - Modified `get_count(using)` to set `annotation_select_mask` to exclude unused annotations from the SELECT clause\n\n## How It Works\n1. When `get_count()` is called, it finds which annotations are \"used\" (referenced by filters, ordering, or other annotations)\n2. Instead of deleting unused annotations (which would break the subquery logic), it sets the `annotation_select_mask` to exclude them from the SELECT clause\n3. This keeps the annotations in the dict (so `get_aggregation` uses the subquery path when needed) but excludes them from the SQL SELECT\n4. The subquery approach ensures that the joins don't affect the final count\n\n## Test Results\n- All 65 aggregation_regress tests pass\n- All 468 query tests pass\n- All 61 basic tests pass\n\n## Examples\n- `Book.objects.annotate(Count('chapters')).count()` - The Count annotation is now excluded from the SQL (previously it was included despite not being used)\n- `Book.objects.annotate(Count('chapters')).filter(chapters__gt=0).count()` - The Count annotation is kept because it's referenced by the filter\n- `Book.objects.annotate(Count('chapters')).order_by('chapters').count()` - The Count annotation is kept because it's referenced by the ordering",
      "created_at": "2026-02-03T10:47:20.812Z"
    },
    {
      "epic_id": "448ccd12-cffe-46ca-bb7f-fb3219d0f983",
      "epic_title": "Fix: django__django-16263",
      "comment_id": "65700f25-799e-4e78-aa75-dd5d03d6a633",
      "author_name": "Code Reviewer",
      "content": "## Code Review PASSED\n\n**Summary:** The fix correctly strips unused annotations from the SELECT clause in count queries by masking them via `set_annotation_mask`, while preserving them in `self.annotations` to ensure the subquery path in `get_aggregation` is still taken when needed.\n\n**Verified:**\n1. **No test files modified** \u2014 only `django/db/models/sql/query.py` changed.\n2. **Mask + `__count` interaction correct** \u2014 `set_annotation_mask(used_names)` is called first, then `add_annotation(__count)` internally calls `append_annotation_mask([\"__count\"])`, which unions `__count` into the mask. So the count aggregate is always included in SELECT.\n3. **WhereNode traversal correct** \u2014 `WhereNode.get_source_expressions()` returns `self.children[:]`, so `_get_annotation_refs` recursively traverses nested WHERE clauses (e.g., from `Q(a=1) | Q(b=2)`).\n4. **Subquery path preserved** \u2014 Masked annotations remain in `self.annotations`, so `existing_annotations` in `get_aggregation` is non-empty and the subquery path is correctly taken, preventing incorrect counts from JOINs.\n5. **Transitive annotation dependencies handled** \u2014 The while-loop discovers annotations referenced by other used annotations.\n6. **Edge cases safe** \u2014 No annotations or all-used annotations skip the mask entirely, preserving existing behavior.\n7. **Tests pass** \u2014 aggregation_regress (65), query (468), basic (61) all green.\n\nNo issues found. Fix is correct and focused.",
      "created_at": "2026-02-03T10:52:04.581Z"
    }
  ]
}