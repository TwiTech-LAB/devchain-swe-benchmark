{
  "instance_id": "django__django-14011",
  "status": "completed",
  "patch": "diff --git a/django/core/servers/basehttp.py b/django/core/servers/basehttp.py\nindex 14dab517c9..6cc8a46778 100644\n--- a/django/core/servers/basehttp.py\n+++ b/django/core/servers/basehttp.py\n@@ -16,6 +16,7 @@ from wsgiref import simple_server\n from django.core.exceptions import ImproperlyConfigured\n from django.core.handlers.wsgi import LimitedStream\n from django.core.wsgi import get_wsgi_application\n+from django.db import connections\n from django.utils.module_loading import import_string\n \n __all__ = ('WSGIServer', 'WSGIRequestHandler')\n@@ -81,6 +82,28 @@ class ThreadedWSGIServer(socketserver.ThreadingMixIn, WSGIServer):\n     \"\"\"A threaded version of the WSGIServer\"\"\"\n     daemon_threads = True\n \n+    def __init__(self, *args, connections_override=None, **kwargs):\n+        super().__init__(*args, **kwargs)\n+        self.connections_override = connections_override\n+\n+    # socketserver.ThreadingMixIn.process_request() passes this method as\n+    # the target to a new Thread object.\n+    def process_request_thread(self, request, client_address):\n+        if self.connections_override:\n+            # Override this thread's database connections with the ones\n+            # provided by the parent thread.\n+            for alias, conn in self.connections_override.items():\n+                connections[alias] = conn\n+        super().process_request_thread(request, client_address)\n+\n+    def _close_connections(self):\n+        # Used for mocking in tests.\n+        connections.close_all()\n+\n+    def close_request(self, request):\n+        self._close_connections()\n+        super().close_request(request)\n+\n \n class ServerHandler(simple_server.ServerHandler):\n     http_version = '1.1'\ndiff --git a/django/test/testcases.py b/django/test/testcases.py\nindex 92f566b7b0..991fa72dff 100644\n--- a/django/test/testcases.py\n+++ b/django/test/testcases.py\n@@ -1500,7 +1500,7 @@ class LiveServerThread(threading.Thread):\n         try:\n             # Create the handler for serving static and media files\n             handler = self.static_handler(_MediaFilesHandler(WSGIHandler()))\n-            self.httpd = self._create_server()\n+            self.httpd = self._create_server(self.connections_override)\n             # If binding to port zero, assign the port allocated by the OS.\n             if self.port == 0:\n                 self.port = self.httpd.server_address[1]\n@@ -1513,11 +1513,12 @@ class LiveServerThread(threading.Thread):\n         finally:\n             connections.close_all()\n \n-    def _create_server(self):\n+    def _create_server(self, connections_override=None):\n         return self.server_class(\n             (self.host, self.port),\n             QuietWSGIRequestHandler,\n             allow_reuse_address=False,\n+            connections_override=connections_override,\n         )\n \n     def terminate(self):\n@@ -1593,7 +1594,7 @@ class LiveServerTestCase(TransactionTestCase):\n     def _tearDownClassInternal(cls):\n         # Terminate the live server's thread.\n         cls.server_thread.terminate()\n-        # Restore sqlite in-memory database connections' non-shareability.\n+        # Restore shared connections' non-shareability.\n         for conn in cls.server_thread.connections_override.values():\n             conn.dec_thread_sharing()\n \n",
  "epics_created": 1,
  "epics_completed": 1,
  "start_time": "2026-02-03T11:37:21.903865",
  "end_time": "2026-02-03T11:44:23.748294",
  "duration_seconds": 421.844429,
  "error_message": null,
  "workspace_path": "<redacted>",
  "epic_comments": [
    {
      "epic_id": "86e71d40-4671-4bf1-a04a-762d37fc6258",
      "epic_title": "Fix: django__django-14011",
      "comment_id": "e83419ee-a0ec-4c4f-b538-21cdfac3d3dc",
      "author_name": "Brainstormer",
      "content": "## Fix Summary\n\nFixed the issue where `ThreadedWSGIServer` doesn't close database connections after each thread, which caused `OperationalError: database \"test_myapp\" is being accessed by other users` when `destroy_test_db()` is called in `LiveServerTestCase` tests.\n\n## Root Cause\n\nWhen using `ThreadedWSGIServer`, the `ThreadingMixIn` creates daemon threads to handle HTTP requests. These threads open database connections to handle WSGI requests, but these connections were not being closed when the request handler finished. When the server shut down and Django tried to destroy the test database, some connections were still active, causing the error.\n\n## Changes Made\n\n### 1. django/core/servers/basehttp.py\n- Added `from django.db import connections` import\n- Modified `ThreadedWSGIServer` class:\n  - Added `__init__` method to accept and store `connections_override` parameter\n  - Added `process_request_thread` method to override database connections in request handler threads with shared connections (for in-memory SQLite)\n  - Added `_close_connections` method to close all database connections (mockable for testing)\n  - Added `close_request` method to ensure connections are closed after each request\n\n### 2. django/test/testcases.py\n- Updated `LiveServerThread._create_server` to accept `connections_override` parameter and pass it to the server class\n- Updated `LiveServerThread.run` to pass `self.connections_override` when creating the server\n- Updated comment in `LiveServerTestCase._tearDownClassInternal` to say \"shared connections\" instead of \"sqlite in-memory database connections\"\n\n## Test Results\n- Syntax verified for both modified files\n- Verified that `ThreadedWSGIServer.close_request()` correctly calls `connections.close_all()`\n- Verified that `process_request_thread` correctly overrides connections\n\n## Edge Cases Considered\n- Empty `connections_override` (None): The `if self.connections_override:` check handles this gracefully\n- Multiple database aliases: The fix iterates over all connections in `connections_override`\n- Thread safety: Each request handler thread gets its own copy of the shared connection and closes it when done",
      "created_at": "2026-02-03T10:42:57.569Z"
    },
    {
      "epic_id": "86e71d40-4671-4bf1-a04a-762d37fc6258",
      "epic_title": "Fix: django__django-14011",
      "comment_id": "2aa3f356-2172-4bd9-a64f-1ad971e74121",
      "author_name": "Code Reviewer",
      "content": "## Code Review PASSED\n\nThe fix correctly addresses the problem where `ThreadedWSGIServer` leaves database connections open after each request handler thread finishes, causing `OperationalError: database \"test_myapp\" is being accessed by other users` during teardown.\n\n### What the fix does:\n1. **`close_request()` override** \u2014 Calls `connections.close_all()` after each request is handled, ensuring no lingering DB connections from handler threads. This is the core fix.\n2. **`process_request_thread()` override** \u2014 Correctly propagates `connections_override` (shared in-memory SQLite connections) into each handler thread, maintaining existing behavior for in-memory databases.\n3. **`_create_server()` updated** \u2014 Passes `connections_override` from `LiveServerThread` through to `ThreadedWSGIServer`, enabling the above.\n\n### Checklist:\n- \u2705 No test files modified\n- \u2705 No unrelated files modified\n- \u2705 Fix logically addresses the described problem (thread DB connections not being closed)\n- \u2705 No crash bugs \u2014 `connections.close_all()` is standard Django API, `None` guard is correct, `super()` chains are proper\n- \u2705 Changes are minimal and focused",
      "created_at": "2026-02-03T10:44:13.678Z"
    }
  ]
}