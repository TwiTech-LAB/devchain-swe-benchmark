diff --git a/sphinx/builders/linkcheck.py b/sphinx/builders/linkcheck.py
index dd5317087..c6cba2c9e 100644
--- a/sphinx/builders/linkcheck.py
+++ b/sphinx/builders/linkcheck.py
@@ -116,6 +116,68 @@ class CheckExternalLinksBuilder(Builder):
         if self.app.config.linkcheck_timeout:
             kwargs['timeout'] = self.app.config.linkcheck_timeout
 
+        def check_local_reference(uri: str, docname: str) -> Tuple[str, str, int]:
+            """Check if a local/internal reference exists.
+
+            Returns (status, info, code) tuple where status is one of:
+            - 'working': reference exists
+            - 'broken': reference does not exist
+            """
+            # Get the standard domain which contains all reference labels
+            std_domain = self.env.get_domain('std')
+
+            # Handle anchor-only references (same document)
+            if uri.startswith('#'):
+                anchor = uri[1:]
+                doctree = self.env.get_doctree(docname)
+                if anchor in doctree.ids:
+                    return 'working', '', 0
+                else:
+                    return 'broken', __('anchor not found: %s') % anchor, 0
+
+            # Handle references to labels (same-document or cross-document)
+            # These are simple names like 'local-link' or 'some-section'
+            # Check in both named labels and anonymous labels
+            if uri in std_domain.labels:
+                # Reference exists - it's a named label with a title
+                return 'working', '', 0
+            elif uri in std_domain.anonlabels:
+                # Reference exists - it's an anonymous label
+                return 'working', '', 0
+            elif uri in self.env.all_docs:
+                # Reference exists - it's a document name
+                return 'working', '', 0
+            else:
+                # Reference might be a combination of docname#anchor or other formats
+                # Try to parse it
+                if '#' in uri:
+                    doc_ref, anchor = uri.split('#', 1)
+                    # Check if it's docname#anchor format
+                    if doc_ref in self.env.all_docs:
+                        doctree = self.env.get_doctree(doc_ref)
+                        if anchor in doctree.ids:
+                            return 'working', '', 0
+                        else:
+                            return 'broken', __('anchor %r not found in %r') % (anchor, doc_ref), 0
+                    # Check if it's a label#anchor format (label in a document)
+                    elif doc_ref in std_domain.labels:
+                        target_docname, labelid, _ = std_domain.labels[doc_ref]
+                        doctree = self.env.get_doctree(target_docname)
+                        if anchor in doctree.ids:
+                            return 'working', '', 0
+                        else:
+                            return 'broken', __('anchor %r not found in %r') % (anchor, target_docname), 0
+                    elif doc_ref in std_domain.anonlabels:
+                        target_docname, labelid = std_domain.anonlabels[doc_ref]
+                        doctree = self.env.get_doctree(target_docname)
+                        if anchor in doctree.ids:
+                            return 'working', '', 0
+                        else:
+                            return 'broken', __('anchor %r not found in %r') % (anchor, target_docname), 0
+
+                # Reference not found
+                return 'broken', __('local reference not found: %s') % uri, 0
+
         def get_request_headers() -> Dict:
             url = urlparse(uri)
             candidates = ["%s://%s" % (url.scheme, url.netloc),
@@ -210,10 +272,11 @@ class CheckExternalLinksBuilder(Builder):
 
         def check() -> Tuple[str, str, int]:
             # check for various conditions without bothering the network
-            if len(uri) == 0 or uri.startswith(('#', 'mailto:', 'ftp:')):
+            if len(uri) == 0 or uri.startswith(('mailto:', 'ftp:')):
                 return 'unchecked', '', 0
             elif not uri.startswith(('http:', 'https:')):
-                return 'local', '', 0
+                # Check local/internal references
+                return check_local_reference(uri, docname)
             elif uri in self.good:
                 return 'working', 'old', 0
             elif uri in self.broken:
diff --git a/tox.ini b/tox.ini
index bddd822a6..34baee205 100644
--- a/tox.ini
+++ b/tox.ini
@@ -27,7 +27,7 @@ extras =
 setenv =
     PYTHONWARNINGS = all,ignore::ImportWarning:importlib._bootstrap_external,ignore::DeprecationWarning:site,ignore::DeprecationWarning:distutils
 commands=
-    pytest --durations 25 {posargs}
+    pytest -rA --durations 25 {posargs}
 
 [testenv:flake8]
 basepython = python3
