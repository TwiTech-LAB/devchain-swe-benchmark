{
  "instance_id": "pytest-dev__pytest-10356",
  "status": "completed",
  "patch": "diff --git a/src/_pytest/mark/structures.py b/src/_pytest/mark/structures.py\nindex 800a25c92..8393be27a 100644\n--- a/src/_pytest/mark/structures.py\n+++ b/src/_pytest/mark/structures.py\n@@ -356,10 +356,31 @@ class MarkDecorator:\n \n \n def get_unpacked_marks(obj: object) -> Iterable[Mark]:\n-    \"\"\"Obtain the unpacked marks that are stored on an object.\"\"\"\n-    mark_list = getattr(obj, \"pytestmark\", [])\n-    if not isinstance(mark_list, list):\n-        mark_list = [mark_list]\n+    \"\"\"Obtain the unpacked marks that are stored on an object.\n+\n+    For classes, this also considers marks from base classes according to\n+    the MRO (Method Resolution Order), enabling marks from all base classes\n+    to be inherited (e.g., when using multiple inheritance).\n+    \"\"\"\n+    if isinstance(obj, type):\n+        # For classes, collect marks from the class's own __dict__ and all\n+        # base classes' __dict__ (not via getattr, to avoid MRO issues)\n+        mark_list = []\n+        # Iterate in reverse MRO order so derived class marks come last\n+        for basecls in reversed(obj.__mro__):\n+            # Look directly in __dict__ to avoid MRO attribute lookup which\n+            # would stop at the first parent with pytestmark\n+            base_marks = basecls.__dict__.get(\"pytestmark\")\n+            if base_marks is not None:\n+                if not isinstance(base_marks, list):\n+                    base_marks = [base_marks]\n+                mark_list.extend(base_marks)\n+    else:\n+        # For functions and other objects, use normal attribute lookup\n+        mark_list = getattr(obj, \"pytestmark\", [])\n+        if not isinstance(mark_list, list):\n+            mark_list = [mark_list]\n+\n     return normalize_mark_list(mark_list)\n \n \n@@ -388,7 +409,21 @@ def store_mark(obj, mark: Mark) -> None:\n     assert isinstance(mark, Mark), mark\n     # Always reassign name to avoid updating pytestmark in a reference that\n     # was only borrowed.\n-    obj.pytestmark = [*get_unpacked_marks(obj), mark]\n+    # For classes, only look at the class's own marks (not inherited),\n+    # to avoid duplicating marks from the MRO.\n+    if isinstance(obj, type):\n+        existing_mark_list = obj.__dict__.get(\"pytestmark\")\n+    else:\n+        existing_mark_list = getattr(obj, \"pytestmark\", None)\n+\n+    if existing_mark_list is None:\n+        existing_marks = []\n+    elif not isinstance(existing_mark_list, list):\n+        existing_marks = [existing_mark_list]\n+    else:\n+        existing_marks = list(existing_mark_list)\n+\n+    obj.pytestmark = [*existing_marks, mark]\n \n \n # Typing for builtin pytest marks. This is cheating; it gives builtin marks\n",
  "epics_created": 1,
  "epics_completed": 1,
  "start_time": "2026-02-03T15:38:21.692973",
  "end_time": "2026-02-03T15:50:02.062848",
  "duration_seconds": 700.369875,
  "error_message": null,
  "workspace_path": "<redacted>",
  "epic_comments": [
    {
      "epic_id": "c6f8f267-c249-41fe-afdf-b48f5f5393c4",
      "epic_title": "Fix: pytest-dev__pytest-10356",
      "comment_id": "d9b853da-b40f-44d0-8ce9-20ef7aaf702c",
      "author_name": "Brainstormer",
      "content": "## Fix Summary\n\nFixed the issue where pytest markers from multiple base classes were not being inherited when using multiple inheritance (e.g., `class TestDings(Foo, Bar)`).\n\n**Root Cause:** The `get_unpacked_marks` function in `src/_pytest/mark/structures.py` only retrieved marks from the object's `pytestmark` attribute. For classes with multiple inheritance, Python's normal attribute lookup (via `getattr`) uses MRO and stops at the first parent with the attribute, so marks from other parents were never found.\n\n**Solution:** \n1. Modified `get_unpacked_marks` to iterate through the MRO and collect marks from each base class's `__dict__` directly (bypassing normal attribute lookup)\n2. Modified `store_mark` to only look at the class's own marks (not inherited) to avoid duplicating marks when storing decorators\n\n## Files Modified\n- `src/_pytest/mark/structures.py`: \n  - `get_unpacked_marks`: Now traverses MRO for classes to collect marks from all base classes\n  - `store_mark`: Changed to only look at the object's own `__dict__` for existing marks to prevent duplicates\n\n## Test Results\n- **Test file:** `testing/test_mark.py`\n- **Baseline (before fix):** 88 passed, 1 xfailed\n- **After fix:** 88 passed, 1 xfailed\n- **Regression check:** No new failures introduced\n- **Collection tests:** 83 passed, 1 skipped, 1 xfailed (same as baseline)\n\n## Additional Verification\nVerified the fix works with the original problem case:\n```python\n@pytest.mark.foo\nclass Foo: pass\n\n@pytest.mark.bar\nclass Bar: pass\n\nclass TestDings(Foo, Bar):\n    def test_dings(self): pass\n```\n\nBefore fix: Only `foo` marker was present\nAfter fix: Both `foo` and `bar` markers are present\n\nTests confirmed:\n- `pytest -m foo` - matches \u2713\n- `pytest -m bar` - matches \u2713\n- `pytest -m \"foo and bar\"` - matches \u2713\n\n## Concerns\nNone - the fix is minimal and focused on the specific issue. The existing test `test_mark_decorator_baseclasses_merged` continues to pass, confirming linear inheritance still works correctly.",
      "created_at": "2026-02-03T14:48:21.758Z"
    },
    {
      "epic_id": "c6f8f267-c249-41fe-afdf-b48f5f5393c4",
      "epic_title": "Fix: pytest-dev__pytest-10356",
      "comment_id": "52826ad3-c78a-4ff8-8410-91097de7f957",
      "author_name": "Code Reviewer",
      "content": "## Code Review PASSED\n\n**Review Checklist:**\n- [x] No test files modified \u2014 only `src/_pytest/mark/structures.py` changed\n- [x] No unrelated files modified\n- [x] Fix logically addresses the problem\n- [x] No obvious crash bugs or logical errors\n- [x] Changes are minimal and focused\n\n**Analysis:**\n\nThe fix correctly addresses the root cause: `getattr(cls, 'pytestmark')` follows MRO and stops at the first parent that defines the attribute, causing marks from other base classes to be lost in multiple inheritance scenarios.\n\n**`get_unpacked_marks` change:** Iterating through `reversed(obj.__mro__)` and accessing each class's `__dict__` directly bypasses normal MRO attribute resolution, collecting marks from ALL base classes. Reverse MRO order ensures derived class marks come after base class marks, maintaining expected precedence. Edge cases (no pytestmark, non-list pytestmark, `object` in MRO) are all handled correctly.\n\n**`store_mark` change:** Using `obj.__dict__.get(\"pytestmark\")` instead of the previous `get_unpacked_marks(obj)` is essential \u2014 since `get_unpacked_marks` now collects marks from all base classes, using it in `store_mark` would duplicate inherited marks when applying a decorator. Only accessing the class's own `__dict__` prevents this duplication.\n\nTests show no regressions (88 passed, 1 xfailed \u2014 same as baseline). The fix was also verified against the exact reproduction case from the problem statement.",
      "created_at": "2026-02-03T14:49:53.678Z"
    }
  ]
}