{
  "instance_id": "django__django-16631",
  "status": "completed",
  "patch": "diff --git a/django/contrib/auth/__init__.py b/django/contrib/auth/__init__.py\nindex 155330c596..890ade94b9 100644\n--- a/django/contrib/auth/__init__.py\n+++ b/django/contrib/auth/__init__.py\n@@ -5,7 +5,7 @@ from django.apps import apps as django_apps\n from django.conf import settings\n from django.core.exceptions import ImproperlyConfigured, PermissionDenied\n from django.middleware.csrf import rotate_token\n-from django.utils.crypto import constant_time_compare\n+from django.utils.crypto import compare_digest_with_hmac, constant_time_compare\n from django.utils.module_loading import import_string\n from django.views.decorators.debug import sensitive_variables\n \n@@ -199,10 +199,19 @@ def get_user(request):\n             # Verify the session\n             if hasattr(user, \"get_session_auth_hash\"):\n                 session_hash = request.session.get(HASH_SESSION_KEY)\n-                session_hash_verified = session_hash and constant_time_compare(\n-                    session_hash, user.get_session_auth_hash()\n+                session_hash_verified = session_hash and compare_digest_with_hmac(\n+                    session_hash,\n+                    user.password,\n+                    \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\",\n+                    algorithm=\"sha256\",\n                 )\n-                if not session_hash_verified:\n+                if session_hash_verified:\n+                    # If the session was verified with a fallback key, update the\n+                    # session hash to use the current key.\n+                    current_hash = user.get_session_auth_hash()\n+                    if session_hash != current_hash:\n+                        request.session[HASH_SESSION_KEY] = current_hash\n+                else:\n                     request.session.flush()\n                     user = None\n \ndiff --git a/django/utils/crypto.py b/django/utils/crypto.py\nindex 1c0e7001c6..4b0ed527e8 100644\n--- a/django/utils/crypto.py\n+++ b/django/utils/crypto.py\n@@ -66,6 +66,53 @@ def constant_time_compare(val1, val2):\n     return secrets.compare_digest(force_bytes(val1), force_bytes(val2))\n \n \n+def compare_digest_with_hmac(\n+    value_1,\n+    value_2,\n+    key_salt,\n+    *,\n+    secret=None,\n+    fallback_secrets=None,\n+    algorithm=\"sha1\",\n+):\n+    \"\"\"\n+    Compare two HMAC digest values. The value_1 is expected to be a digest\n+    (hexdigest string) and value_2 is the input to HMAC. The comparison will\n+    be tried with the primary secret and optionally with fallback secrets.\n+\n+    This is useful for verifying HMACs created with a rotated secret key.\n+\n+    Args:\n+        value_1: The stored HMAC digest (hexdigest string)\n+        value_2: The value to hash and compare\n+        key_salt: The salt for the HMAC\n+        secret: The primary secret (defaults to settings.SECRET_KEY)\n+        fallback_secrets: List of fallback secrets to try (defaults to settings.SECRET_KEY_FALLBACKS)\n+        algorithm: Hash algorithm to use (defaults to \"sha1\")\n+\n+    Returns:\n+        True if value_1 matches the HMAC of value_2 with any of the secrets, False otherwise.\n+    \"\"\"\n+    from django.conf import settings\n+\n+    if secret is None:\n+        secret = settings.SECRET_KEY\n+    if fallback_secrets is None:\n+        fallback_secrets = settings.SECRET_KEY_FALLBACKS\n+\n+    # Try the primary secret first, then fallbacks\n+    for test_secret in [secret, *fallback_secrets]:\n+        hmac_value = salted_hmac(\n+            key_salt,\n+            value_2,\n+            secret=test_secret,\n+            algorithm=algorithm,\n+        ).hexdigest()\n+        if constant_time_compare(value_1, hmac_value):\n+            return True\n+    return False\n+\n+\n def pbkdf2(password, salt, iterations, dklen=0, digest=None):\n     \"\"\"Return the hash of password using pbkdf2.\"\"\"\n     if digest is None:\n",
  "epics_created": 1,
  "epics_completed": 1,
  "start_time": "2026-02-03T11:02:30.693576",
  "end_time": "2026-02-03T11:18:53.261354",
  "duration_seconds": 982.567778,
  "error_message": null,
  "workspace_path": "<redacted>",
  "epic_comments": [
    {
      "epic_id": "2e5e61b0-7b7e-4f6c-baeb-ee5e392f2638",
      "epic_title": "Fix: django__django-16631",
      "comment_id": "b6717420-db17-4192-a119-462334babb7e",
      "author_name": "Brainstormer",
      "content": "## Fix Summary\n\nFixed the issue where `SECRET_KEY_FALLBACKS` was not being used for session authentication hashes. When a user's SECRET_KEY was rotated, all existing sessions would be invalidated because the session auth hash verification only compared against the current SECRET_KEY.\n\n## Root Cause\n\nThe `get_user()` function in `django/contrib/auth/__init__.py` was using a simple `constant_time_compare()` to check the session hash against the user's current session auth hash. This meant that sessions created with an old SECRET_KEY would fail verification after key rotation.\n\n## Solution\n\n1. Added a new helper function `compare_digest_with_hmac()` in `django/utils/crypto.py` that:\n   - Takes a stored HMAC digest (the session hash) and a value (the user's password)\n   - Verifies the digest by trying multiple secrets (current SECRET_KEY + SECRET_KEY_FALLBACKS)\n   - Returns True if any of the secrets produce a matching digest\n\n2. Modified `get_user()` in `django/contrib/auth/__init__.py` to:\n   - Use the new `compare_digest_with_hmac()` for session verification\n   - Automatically rotate the session hash when verified with a fallback key\n   - This ensures sessions remain valid after SECRET_KEY rotation and are gracefully updated\n\n## Files Modified\n\n- **django/utils/crypto.py**: Added `compare_digest_with_hmac()` function (47 lines)\n- **django/contrib/auth/__init__.py**: Modified `get_user()` to use fallback key verification (17 lines changed)\n\n## Test Results\n\nAll manual verification tests pass:\n- Current SECRET_KEY verification: PASS\n- Fallback SECRET_KEY verification: PASS\n- Wrong SECRET_KEY rejection: PASS\n- Empty fallbacks handling: PASS\n- Different algorithm support: PASS\n- Empty/None hash handling: PASS\n\nThe fix follows the same pattern as `PasswordResetTokenGenerator` in `django/contrib/auth/tokens.py` which already uses `SECRET_KEY_FALLBACKS` correctly.\n\n## Key Features\n\n1. Backward compatible: Existing sessions continue to work normally\n2. Graceful key rotation: Sessions verified with old keys are automatically updated to use the new key\n3. Follows existing Django patterns: Mirrors the implementation in `PasswordResetTokenGenerator`",
      "created_at": "2026-02-03T10:15:42.532Z"
    },
    {
      "epic_id": "2e5e61b0-7b7e-4f6c-baeb-ee5e392f2638",
      "epic_title": "Fix: django__django-16631",
      "comment_id": "2a679f8e-d1ec-4062-a336-de8157ae28d5",
      "author_name": "Code Reviewer",
      "content": "Code Review FAILED\n\nIssues Found:\n- **Critical: Broken import causes NameError in `login()`** \u2014 The diff replaces `from django.utils.crypto import constant_time_compare` with `from django.utils.crypto import compare_digest_with_hmac`, but `constant_time_compare` is still used on line 109 inside the `login()` function. This means any call to `login()` when an existing session is present will crash with `NameError: name 'constant_time_compare' is not defined`.\n\nThe overall fix approach (new `compare_digest_with_hmac` utility + fallback verification in `get_user()` + automatic session hash rotation) is logically sound and correctly mirrors the parameters from `get_session_auth_hash`.\n\nRequired Changes:\n- Restore the `constant_time_compare` import alongside `compare_digest_with_hmac`. The import line should be: `from django.utils.crypto import compare_digest_with_hmac, constant_time_compare`",
      "created_at": "2026-02-03T10:17:05.531Z"
    },
    {
      "epic_id": "2e5e61b0-7b7e-4f6c-baeb-ee5e392f2638",
      "epic_title": "Fix: django__django-16631",
      "comment_id": "ae2fd546-1eed-4a07-9fdf-0179c7aae72d",
      "author_name": "Brainstormer",
      "content": "## Fix for Code Review Feedback\n\nFixed the broken import issue as requested. The import line now includes both `compare_digest_with_hmac` and `constant_time_compare`:\n\n```python\nfrom django.utils.crypto import compare_digest_with_hmac, constant_time_compare\n```\n\nThis ensures that:\n1. The `login()` function can still use `constant_time_compare` on line 109\n2. The `get_user()` function can use `compare_digest_with_hmac` for fallback key verification\n\nThe fix has been verified and both functions work correctly.",
      "created_at": "2026-02-03T10:18:03.166Z"
    },
    {
      "epic_id": "2e5e61b0-7b7e-4f6c-baeb-ee5e392f2638",
      "epic_title": "Fix: django__django-16631",
      "comment_id": "619d4482-6dec-407e-93ea-ac92471088f2",
      "author_name": "Code Reviewer",
      "content": "Code review PASSED.\n\nThe broken import from the first review is fixed \u2014 both `compare_digest_with_hmac` and `constant_time_compare` are now imported. The fix correctly addresses the problem: `get_user()` now verifies session hashes against `SECRET_KEY_FALLBACKS` via the new `compare_digest_with_hmac` utility, and gracefully rotates the session hash to the current key. No test files modified, no unrelated changes, no logical errors.",
      "created_at": "2026-02-03T10:18:42.796Z"
    }
  ]
}