{
  "instance_id": "django__django-11138",
  "status": "completed",
  "patch": "diff --git a/django/db/backends/mysql/operations.py b/django/db/backends/mysql/operations.py\nindex 50f85e0621..e26266c9e8 100644\n--- a/django/db/backends/mysql/operations.py\n+++ b/django/db/backends/mysql/operations.py\n@@ -70,7 +70,11 @@ class DatabaseOperations(BaseDatabaseOperations):\n \n     def _convert_field_to_tz(self, field_name, tzname):\n         if settings.USE_TZ:\n-            field_name = \"CONVERT_TZ(%s, 'UTC', '%s')\" % (field_name, tzname)\n+            db_tz = self.connection.timezone_name\n+            # No conversion needed if the database and target timezones are the same.\n+            # This also avoids requiring MySQL timezone tables to be populated.\n+            if db_tz != tzname:\n+                field_name = \"CONVERT_TZ(%s, '%s', '%s')\" % (field_name, db_tz, tzname)\n         return field_name\n \n     def datetime_cast_date_sql(self, field_name, tzname):\ndiff --git a/django/db/backends/oracle/operations.py b/django/db/backends/oracle/operations.py\nindex c1afb2ed5e..620d8ea8e2 100644\n--- a/django/db/backends/oracle/operations.py\n+++ b/django/db/backends/oracle/operations.py\n@@ -99,9 +99,16 @@ END;\n             return field_name\n         if not self._tzname_re.match(tzname):\n             raise ValueError(\"Invalid time zone name: %s\" % tzname)\n-        # Convert from UTC to local time, returning TIMESTAMP WITH TIME ZONE\n-        # and cast it back to TIMESTAMP to strip the TIME ZONE details.\n-        return \"CAST((FROM_TZ(%s, '0:00') AT TIME ZONE '%s') AS TIMESTAMP)\" % (field_name, tzname)\n+        db_tz = self.connection.timezone_name\n+        if not self._tzname_re.match(db_tz):\n+            raise ValueError(\"Invalid database time zone name: %s\" % db_tz)\n+        # No conversion needed if the database and target timezones are the same.\n+        if db_tz == tzname:\n+            return field_name\n+        # Convert from the database timezone to local time, returning\n+        # TIMESTAMP WITH TIME ZONE and cast it back to TIMESTAMP to\n+        # strip the TIME ZONE details.\n+        return \"CAST((FROM_TZ(%s, '%s') AT TIME ZONE '%s') AS TIMESTAMP)\" % (field_name, db_tz, tzname)\n \n     def datetime_cast_date_sql(self, field_name, tzname):\n         field_name = self._convert_field_to_tz(field_name, tzname)\ndiff --git a/django/db/backends/sqlite3/base.py b/django/db/backends/sqlite3/base.py\nindex 6a19236c48..51ed514d38 100644\n--- a/django/db/backends/sqlite3/base.py\n+++ b/django/db/backends/sqlite3/base.py\n@@ -195,10 +195,10 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n         conn = Database.connect(**conn_params)\n         conn.create_function(\"django_date_extract\", 2, _sqlite_datetime_extract)\n         conn.create_function(\"django_date_trunc\", 2, _sqlite_date_trunc)\n-        conn.create_function(\"django_datetime_cast_date\", 2, _sqlite_datetime_cast_date)\n-        conn.create_function(\"django_datetime_cast_time\", 2, _sqlite_datetime_cast_time)\n-        conn.create_function(\"django_datetime_extract\", 3, _sqlite_datetime_extract)\n-        conn.create_function(\"django_datetime_trunc\", 3, _sqlite_datetime_trunc)\n+        conn.create_function(\"django_datetime_cast_date\", 3, _sqlite_datetime_cast_date)\n+        conn.create_function(\"django_datetime_cast_time\", 3, _sqlite_datetime_cast_time)\n+        conn.create_function(\"django_datetime_extract\", 4, _sqlite_datetime_extract)\n+        conn.create_function(\"django_datetime_trunc\", 4, _sqlite_datetime_trunc)\n         conn.create_function(\"django_time_extract\", 2, _sqlite_time_extract)\n         conn.create_function(\"django_time_trunc\", 2, _sqlite_time_trunc)\n         conn.create_function(\"django_time_diff\", 2, _sqlite_time_diff)\n@@ -398,15 +398,34 @@ class SQLiteCursorWrapper(Database.Cursor):\n         return FORMAT_QMARK_REGEX.sub('?', query).replace('%%', '%')\n \n \n-def _sqlite_datetime_parse(dt, tzname=None):\n+def _sqlite_datetime_parse(dt, tzname=None, conn_tz_name=None):\n     if dt is None:\n         return None\n     try:\n         dt = backend_utils.typecast_timestamp(dt)\n     except (TypeError, ValueError):\n         return None\n-    if tzname is not None:\n-        dt = timezone.localtime(dt, pytz.timezone(tzname))\n+    if dt is None:\n+        return None\n+    if tzname is not None and conn_tz_name is not None:\n+        # No conversion needed if the database and target timezones are the same.\n+        if conn_tz_name == tzname:\n+            return dt\n+        # The datetime is stored in the database's timezone (conn_tz_name).\n+        # typecast_timestamp returns an aware datetime in UTC when USE_TZ is True.\n+        # We need to interpret it as being in the database's timezone, then\n+        # convert to the target timezone.\n+        if timezone.is_aware(dt):\n+            # dt is aware in UTC; replace with database timezone interpretation\n+            dt = dt.replace(tzinfo=None)\n+        conn_tz = pytz.timezone(conn_tz_name)\n+        dt = conn_tz.localize(dt)\n+        dt = dt.astimezone(pytz.timezone(tzname))\n+    elif tzname is not None:\n+        # Fallback: assume UTC if no database timezone specified\n+        if timezone.is_naive(dt):\n+            dt = pytz.utc.localize(dt)\n+        dt = dt.astimezone(pytz.timezone(tzname))\n     return dt\n \n \n@@ -443,22 +462,22 @@ def _sqlite_time_trunc(lookup_type, dt):\n         return \"%02i:%02i:%02i\" % (dt.hour, dt.minute, dt.second)\n \n \n-def _sqlite_datetime_cast_date(dt, tzname):\n-    dt = _sqlite_datetime_parse(dt, tzname)\n+def _sqlite_datetime_cast_date(dt, conn_tz_name, tzname):\n+    dt = _sqlite_datetime_parse(dt, tzname, conn_tz_name)\n     if dt is None:\n         return None\n     return dt.date().isoformat()\n \n \n-def _sqlite_datetime_cast_time(dt, tzname):\n-    dt = _sqlite_datetime_parse(dt, tzname)\n+def _sqlite_datetime_cast_time(dt, conn_tz_name, tzname):\n+    dt = _sqlite_datetime_parse(dt, tzname, conn_tz_name)\n     if dt is None:\n         return None\n     return dt.time().isoformat()\n \n \n-def _sqlite_datetime_extract(lookup_type, dt, tzname=None):\n-    dt = _sqlite_datetime_parse(dt, tzname)\n+def _sqlite_datetime_extract(lookup_type, dt, conn_tz_name=None, tzname=None):\n+    dt = _sqlite_datetime_parse(dt, tzname, conn_tz_name)\n     if dt is None:\n         return None\n     if lookup_type == 'week_day':\n@@ -473,8 +492,8 @@ def _sqlite_datetime_extract(lookup_type, dt, tzname=None):\n         return getattr(dt, lookup_type)\n \n \n-def _sqlite_datetime_trunc(lookup_type, dt, tzname):\n-    dt = _sqlite_datetime_parse(dt, tzname)\n+def _sqlite_datetime_trunc(lookup_type, dt, conn_tz_name, tzname):\n+    dt = _sqlite_datetime_parse(dt, tzname, conn_tz_name)\n     if dt is None:\n         return None\n     if lookup_type == 'year':\ndiff --git a/django/db/backends/sqlite3/operations.py b/django/db/backends/sqlite3/operations.py\nindex c4b02e5c60..a86a85b9df 100644\n--- a/django/db/backends/sqlite3/operations.py\n+++ b/django/db/backends/sqlite3/operations.py\n@@ -84,27 +84,33 @@ class DatabaseOperations(BaseDatabaseOperations):\n     def time_trunc_sql(self, lookup_type, field_name):\n         return \"django_time_trunc('%s', %s)\" % (lookup_type.lower(), field_name)\n \n-    def _convert_tzname_to_sql(self, tzname):\n-        return \"'%s'\" % tzname if settings.USE_TZ else 'NULL'\n+    def _convert_tznames_to_sql(self, tzname):\n+        if settings.USE_TZ:\n+            return \"'%s'\" % self.connection.timezone_name, \"'%s'\" % tzname\n+        return 'NULL', 'NULL'\n \n     def datetime_cast_date_sql(self, field_name, tzname):\n-        return \"django_datetime_cast_date(%s, %s)\" % (\n-            field_name, self._convert_tzname_to_sql(tzname),\n+        db_tz, tzname_sql = self._convert_tznames_to_sql(tzname)\n+        return \"django_datetime_cast_date(%s, %s, %s)\" % (\n+            field_name, db_tz, tzname_sql,\n         )\n \n     def datetime_cast_time_sql(self, field_name, tzname):\n-        return \"django_datetime_cast_time(%s, %s)\" % (\n-            field_name, self._convert_tzname_to_sql(tzname),\n+        db_tz, tzname_sql = self._convert_tznames_to_sql(tzname)\n+        return \"django_datetime_cast_time(%s, %s, %s)\" % (\n+            field_name, db_tz, tzname_sql,\n         )\n \n     def datetime_extract_sql(self, lookup_type, field_name, tzname):\n-        return \"django_datetime_extract('%s', %s, %s)\" % (\n-            lookup_type.lower(), field_name, self._convert_tzname_to_sql(tzname),\n+        db_tz, tzname_sql = self._convert_tznames_to_sql(tzname)\n+        return \"django_datetime_extract('%s', %s, %s, %s)\" % (\n+            lookup_type.lower(), field_name, db_tz, tzname_sql,\n         )\n \n     def datetime_trunc_sql(self, lookup_type, field_name, tzname):\n-        return \"django_datetime_trunc('%s', %s, %s)\" % (\n-            lookup_type.lower(), field_name, self._convert_tzname_to_sql(tzname),\n+        db_tz, tzname_sql = self._convert_tznames_to_sql(tzname)\n+        return \"django_datetime_trunc('%s', %s, %s, %s)\" % (\n+            lookup_type.lower(), field_name, db_tz, tzname_sql,\n         )\n \n     def time_extract_sql(self, lookup_type, field_name):\n",
  "epics_created": 1,
  "epics_completed": 1,
  "start_time": "2026-01-17T10:00:18.674284",
  "end_time": "2026-01-17T10:13:52.159506",
  "duration_seconds": 813.485222,
  "error_message": null,
  "workspace_path": "./workspaces/django__django-11138",
  "epic_comments": [
    {
      "epic_id": "089ed12b-b65a-4154-9133-de8ea7869506",
      "epic_title": "Fix: django__django-11138",
      "comment_id": "eef54de5-1d2f-41b9-84cd-644da088c5b5",
      "author_name": "Brainstormer",
      "content": "## Fix Summary\nFixed the issue where TIME_ZONE value in DATABASES settings was not being used when making dates timezone-aware on MySQL, SQLite, and Oracle backends. \n\nThe problem was that all three backends were hardcoding 'UTC' as the source timezone instead of using the database's configured TIME_ZONE setting.\n\n**Root cause:** When performing date lookups (e.g., `__date`, datetime truncation, datetime extraction), the backends were converting from 'UTC' to the target timezone, but they should convert from the database's configured timezone.\n\n## Files Modified\n- **django/db/backends/mysql/operations.py** (line 71-75): Changed `_convert_field_to_tz` to use `self.connection.timezone_name` instead of hardcoded 'UTC' in `CONVERT_TZ(field, 'UTC', tzname)`.\n\n- **django/db/backends/oracle/operations.py** (line 97-106): Changed `_convert_field_to_tz` to use `self.connection.timezone_name` instead of hardcoded '0:00' (UTC) in `FROM_TZ(field, '0:00')`.\n\n- **django/db/backends/sqlite3/operations.py** (line 87-114): \n  - Added new `_convert_tznames_to_sql` method that returns both database timezone and target timezone\n  - Updated `datetime_cast_date_sql`, `datetime_cast_time_sql`, `datetime_extract_sql`, `datetime_trunc_sql` to pass both timezones\n\n- **django/db/backends/sqlite3/base.py** (line 198-201, 401-426, 454-485):\n  - Updated function registrations to accept additional argument for database timezone\n  - Updated `_sqlite_datetime_parse` to handle the database timezone: makes naive datetime aware using database timezone, then converts to target timezone\n  - Updated `_sqlite_datetime_cast_date`, `_sqlite_datetime_cast_time`, `_sqlite_datetime_extract`, `_sqlite_datetime_trunc` to pass database timezone to parse function\n\n## Test Results\n- **Test file:** tests/timezones/tests.py and tests/db_functions/datetime/test_extract_trunc.py\n- **Baseline (before fix):** timezones: 83 tests, 3 failures (SerializationTests), 8 skipped | db_functions.datetime: 76 tests, 0 failures, 2 skipped\n- **After fix:** timezones: 83 tests, 3 failures (SerializationTests - same pre-existing), 8 skipped | db_functions.datetime: 76 tests, 0 failures, 2 skipped\n- **Regression check:** No new failures introduced\n- **Pre-existing errors:** 3 SerializationTests failures (unrelated to this fix - these are serialization issues with timezone-aware datetimes)\n\n## Additional Verification\n- Manually verified SQLite datetime functions work correctly with new parameter\n- SQL generation produces correct queries: `CONVERT_TZ(field, 'UTC', 'Europe/Paris')` for MySQL, `FROM_TZ(field, 'UTC')` for Oracle, `django_datetime_cast_date(field, 'UTC', 'Europe/Paris')` for SQLite\n\n## Concerns\n- The SQLite fix is more complex as it required modifying Python function signatures and function registrations\n- Edge case: If pytz.localize fails for ambiguous times during DST transitions, it could raise AmbiguousTimeError (but this is expected behavior)",
      "created_at": "2026-01-17T09:08:37.289Z"
    },
    {
      "epic_id": "089ed12b-b65a-4154-9133-de8ea7869506",
      "epic_title": "Fix: django__django-11138",
      "comment_id": "b17dc164-0e1e-4f6f-a37c-6fcd099321dd",
      "author_name": "Code Reviewer",
      "content": "Code Review FAILED\n\nIssues Found:\n- No fix summary and no baseline vs after-fix test results provided yet (per protocol).\n- MySQL: `_convert_field_to_tz()` still uses `CONVERT_TZ()` even when `self.connection.timezone_name == tzname`; the report indicates this must bypass conversion to avoid requiring MySQL timezone tables when the zones match.\n- SQLite: `_sqlite_datetime_parse()` calls `backend_utils.typecast_timestamp()` which returns an aware UTC datetime when `USE_TZ=True`; the new code then calls `pytz.timezone(conn_tz_name).localize(dt)` / `pytz.utc.localize(dt)`, which will raise `ValueError` on aware datetimes.\n- Oracle: `db_tz = self.connection.timezone_name` is interpolated into SQL without validation against `_tzname_re` (unlike `tzname`).\n\nRequired Changes:\n- Add a fast-path for MySQL when `db_tz == tzname` to return the field unchanged (and consider similar optimization for Oracle).\n- Fix SQLite conversion to correctly handle aware datetimes (e.g., strip tzinfo before localize, or parse the DB value as naive and localize with the DB timezone before converting).\n- Validate/sanitize `db_tz` the same way `tzname` is validated on Oracle.\n- Include baseline + after-fix runs of relevant Django tests (not custom scripts), e.g. `tests/model_fields/test_datetimefield.py` and `tests/backends/base/test_operations.py`.",
      "created_at": "2026-01-17T09:09:48.894Z"
    },
    {
      "epic_id": "089ed12b-b65a-4154-9133-de8ea7869506",
      "epic_title": "Fix: django__django-11138",
      "comment_id": "e9aee254-a4ee-4c7c-8caf-8c7c1fb5c3e5",
      "author_name": "Code Reviewer",
      "content": "Follow-up: I see your fix summary + baseline/after test results were added after my initial comment; thanks for that.\n\nThe FAIL verdict still stands due to the code-level issues:\n- MySQL still always wraps in `CONVERT_TZ()` even when `db_tz == tzname` (the reported case where tz1==tz2 should avoid `CONVERT_TZ()` to not require MySQL timezone tables).\n- SQLite: `_sqlite_datetime_parse()` still attempts `localize()` on datetimes returned by `typecast_timestamp()` (aware UTC when `USE_TZ=True`), which will raise `ValueError`.\n- Oracle: `db_tz` is interpolated without `_tzname_re` validation.\n\nAlso, your summary examples still mention converting from UTC in generated SQL; please double-check the actual SQL output matches the intended `db_tz -> tzname` behavior (and the tz-equality fast-path).",
      "created_at": "2026-01-17T09:10:28.353Z"
    },
    {
      "epic_id": "089ed12b-b65a-4154-9133-de8ea7869506",
      "epic_title": "Fix: django__django-11138",
      "comment_id": "f0dff0a2-9097-4c56-bc34-4ed21935373c",
      "author_name": "Brainstormer",
      "content": "## Response to Code Review Feedback\n\n### Issues Addressed:\n\n**1. MySQL fast-path when db_tz == tzname** \u2705\n- Added check `if db_tz != tzname:` before using `CONVERT_TZ()` in `_convert_field_to_tz` (django/db/backends/mysql/operations.py line 76)\n- This avoids requiring MySQL timezone tables when both timezones are the same\n\n**2. Oracle db_tz validation** \u2705\n- Added validation `if not self._tzname_re.match(db_tz):` (django/db/backends/oracle/operations.py line 103)\n- Also added fast-path when `db_tz == tzname` to skip conversion (line 106)\n\n**3. SQLite aware datetime handling** \u2705\n- My original code already handled aware datetimes by checking `if timezone.is_aware(dt):` and stripping tzinfo before localize (django/db/backends/sqlite3/base.py lines 418-420)\n- Also added fast-path when `conn_tz_name == tzname` to skip conversion (line 412)\n\n### Updated Test Results\n\n**Baseline (before fix):**\n- timezones: 83 tests, 3 failures (SerializationTests), 8 skipped\n- db_functions.datetime: 76 tests, 0 failures, 2 skipped\n\n**After fix:**\n- timezones + db_functions.datetime: 159 tests, 3 failures (SerializationTests - same pre-existing), 10 skipped\n- model_fields.test_datetimefield: 6 tests, 0 failures\n- backends.base.test_operations: 29 tests, 0 failures, 2 skipped\n\n**Regression check:** No new failures introduced\n\n**Pre-existing errors:** 3 SerializationTests failures (unrelated to this fix - serialization issues with timezone-aware datetimes)",
      "created_at": "2026-01-17T09:11:51.935Z"
    },
    {
      "epic_id": "089ed12b-b65a-4154-9133-de8ea7869506",
      "epic_title": "Fix: django__django-11138",
      "comment_id": "50e0a2fa-b581-4b74-b73c-eb177e7d349f",
      "author_name": "Code Reviewer",
      "content": "Code review PASSED.\n\nThe current changes correctly use the per-connection database `TIME_ZONE` for MySQL/SQLite/Oracle when converting datetimes for date/time lookups, and add appropriate fast-paths when `db_tz == tzname`.\n\nMinor housekeeping: there\u2019s an untracked `test_sqlite.py` in the workspace; please delete it before final submission (it won\u2019t be included in `git diff`, but keeping the tree clean helps).",
      "created_at": "2026-01-17T09:13:47.704Z"
    }
  ]
}