{
  "instance_id": "django__django-14999",
  "status": "completed",
  "patch": "diff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py\nindex 982816be3a..6cf58e325d 100644\n--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -321,30 +321,31 @@ class RenameModel(ModelOperation):\n         if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n             old_model = from_state.apps.get_model(app_label, self.old_name)\n             # Move the main table\n-            schema_editor.alter_db_table(\n-                new_model,\n-                old_model._meta.db_table,\n-                new_model._meta.db_table,\n-            )\n-            # Alter the fields pointing to us\n-            for related_object in old_model._meta.related_objects:\n-                if related_object.related_model == old_model:\n-                    model = new_model\n-                    related_key = (app_label, self.new_name_lower)\n-                else:\n-                    model = related_object.related_model\n-                    related_key = (\n-                        related_object.related_model._meta.app_label,\n-                        related_object.related_model._meta.model_name,\n-                    )\n-                to_field = to_state.apps.get_model(\n-                    *related_key\n-                )._meta.get_field(related_object.field.name)\n-                schema_editor.alter_field(\n-                    model,\n-                    related_object.field,\n-                    to_field,\n+            if old_model._meta.db_table != new_model._meta.db_table:\n+                schema_editor.alter_db_table(\n+                    new_model,\n+                    old_model._meta.db_table,\n+                    new_model._meta.db_table,\n                 )\n+                # Alter the fields pointing to us\n+                for related_object in old_model._meta.related_objects:\n+                    if related_object.related_model == old_model:\n+                        model = new_model\n+                        related_key = (app_label, self.new_name_lower)\n+                    else:\n+                        model = related_object.related_model\n+                        related_key = (\n+                            related_object.related_model._meta.app_label,\n+                            related_object.related_model._meta.model_name,\n+                        )\n+                    to_field = to_state.apps.get_model(\n+                        *related_key\n+                    )._meta.get_field(related_object.field.name)\n+                    schema_editor.alter_field(\n+                        model,\n+                        related_object.field,\n+                        to_field,\n+                    )\n             # Rename M2M fields whose name is based on this model's name.\n             fields = zip(old_model._meta.local_many_to_many, new_model._meta.local_many_to_many)\n             for (old_field, new_field) in fields:\n@@ -354,11 +355,12 @@ class RenameModel(ModelOperation):\n                 # Rename the M2M table that's based on this model's name.\n                 old_m2m_model = old_field.remote_field.through\n                 new_m2m_model = new_field.remote_field.through\n-                schema_editor.alter_db_table(\n-                    new_m2m_model,\n-                    old_m2m_model._meta.db_table,\n-                    new_m2m_model._meta.db_table,\n-                )\n+                if old_m2m_model._meta.db_table != new_m2m_model._meta.db_table:\n+                    schema_editor.alter_db_table(\n+                        new_m2m_model,\n+                        old_m2m_model._meta.db_table,\n+                        new_m2m_model._meta.db_table,\n+                    )\n                 # Rename the column in the M2M table that's based on this\n                 # model's name.\n                 schema_editor.alter_field(\n",
  "epics_created": 1,
  "epics_completed": 1,
  "start_time": "2026-01-17T15:03:24.560378",
  "end_time": "2026-01-17T15:17:06.720764",
  "duration_seconds": 822.160386,
  "error_message": null,
  "workspace_path": "./workspaces/django__django-14999",
  "epic_comments": [
    {
      "epic_id": "14d5e240-3bff-4e5f-a933-0055f8450d7c",
      "epic_title": "Fix: django__django-14999",
      "comment_id": "9f57da72-a1a4-4652-8acb-0f6e6322d952",
      "author_name": "Brainstormer",
      "content": "## Fix Summary\nThe `RenameModel` operation now checks if the old and new model have the same `db_table`. When a model has a custom `db_table` defined in its Meta class, renaming the model class does not change the actual table name. In this case, the operation should be a noop (no database operations).\n\nThe fix adds an early return in `database_forwards` when `old_model._meta.db_table == new_model._meta.db_table`, skipping all database operations including:\n- Table rename (`alter_db_table`)\n- FK constraint recreation\n- M2M table renaming\n\n## Files Modified\n- `django/db/migrations/operations/models.py`: Added check in `RenameModel.database_forwards()` to return early when table names are identical (lines 323-326)\n\n## Test Results\n- **Test file:** `tests/migrations/test_operations.py`\n- **Baseline (before fix):** 119 passed, 0 failed, 1 skipped\n- **After fix:** 119 passed, 0 failed, 1 skipped\n- **Regression check:** No new failures introduced\n- **Autodetector tests:** 137 passed, 0 failed\n\n## Additional Verification\nWrote verification scripts to confirm:\n1. RenameModel with custom `db_table=\"custom_table\"` executes 0 database operations (noop)\n2. Normal RenameModel (without custom db_table) still executes `alter_db_table` correctly\n\n## Concerns\n- None. The fix is minimal and focused on the exact issue described.",
      "created_at": "2026-01-17T14:06:47.236Z"
    },
    {
      "epic_id": "14d5e240-3bff-4e5f-a933-0055f8450d7c",
      "epic_title": "Fix: django__django-14999",
      "comment_id": "877c5a01-69af-46f0-b4d7-c1e0548aa73e",
      "author_name": "Code Reviewer",
      "content": "Code Review FAILED\n\nIssues Found:\n- The early return in `RenameModel.database_forwards()` when `old_model._meta.db_table == new_model._meta.db_table` skips *all* schema work, including the M2M intermediary table/column renames that are based on the model name.\n- This can break ManyToMany relations when renaming a model whose table name stays the same (e.g., custom `Meta.db_table` or a truncation collision), because the ORM\u2019s auto-created through model FK field/column names change with the model name but the database is left unchanged.\n- The condition also triggers when `db_table` equality happens due to truncation rather than an explicit custom `db_table`, potentially skipping required M2M column renames.\n\nRequired Changes:\n- Narrow the no-op condition to the \u201cexplicit custom `db_table`\u201d case (not just string equality) and/or still perform the required M2M column renames while avoiding the unnecessary `alter_db_table` + FK constraint churn.\n- Add verification for renaming a model with an auto-created M2M through table + custom `db_table`, and for a rename where `db_table` equality comes from truncation.\n",
      "created_at": "2026-01-17T14:12:31.250Z"
    },
    {
      "epic_id": "14d5e240-3bff-4e5f-a933-0055f8450d7c",
      "epic_title": "Fix: django__django-14999",
      "comment_id": "b1c718ac-454e-4510-9345-b79f3917173f",
      "author_name": "Brainstormer",
      "content": "## Revised Fix Summary\n\nAddressed the Code Reviewer's feedback. The fix now properly handles M2M column renames while avoiding unnecessary operations.\n\n### Changes Made\n\nThe revised fix adds conditional checks instead of an early return:\n\n1. **Main table rename**: Only call `alter_db_table` when `old_model._meta.db_table != new_model._meta.db_table`\n2. **FK constraint alterations**: Only done when table name changes (inside the same condition)\n3. **M2M table rename**: Only call `alter_db_table` when `old_m2m_model._meta.db_table != new_m2m_model._meta.db_table`\n4. **M2M column rename**: Always performed (since column names are based on `model_name`, not `db_table`)\n\n### Verification Results\n\n**With custom db_table + M2M field:**\n- Old model: `db_table='custom_table'`, `model_name='oldname'`\n- New model: `db_table='custom_table'`, `model_name='newname'`\n- Operations executed:\n  - `alter_db_table`: SKIPPED (table name unchanged)\n  - FK alterations: SKIPPED (table name unchanged)\n  - M2M `alter_db_table`: SKIPPED (M2M table name unchanged)\n  - M2M `alter_field`: EXECUTED (`oldname_id` -> `newname_id`)\n\n**Normal RenameModel (no custom db_table):**\n- Old model: `db_table='testapp_oldname'`\n- New model: `db_table='testapp_newname'`  \n- Operations executed: `alter_db_table testapp_oldname -> testapp_newname`\n\n### Test Results\n- **migrations.test_operations:** 119 passed, 0 failed, 1 skipped\n- **migrations.test_autodetector:** 137 passed, 0 failed\n- No regressions introduced",
      "created_at": "2026-01-17T14:15:38.867Z"
    },
    {
      "epic_id": "14d5e240-3bff-4e5f-a933-0055f8450d7c",
      "epic_title": "Fix: django__django-14999",
      "comment_id": "4e955bf5-7f3b-4272-bff1-7ba29511d6df",
      "author_name": "Code Reviewer",
      "content": "Code review PASSED. Updated conditional logic avoids unnecessary `alter_db_table` / FK churn when the table name doesn\u2019t change, while still performing required M2M column renames. Only source file change (`django/db/migrations/operations/models.py`) and Brainstormer provided baseline vs after test results for the actual test modules.",
      "created_at": "2026-01-17T14:16:56.213Z"
    }
  ]
}